---
title: 'Serialization · Techniques'
description: 'Control how responses are converted to JSON across HTTP and GraphQL using class-transformer with DI-driven settings.'
---

import Link from 'next/link';
import { Badge } from '@/components/ui/badge';
import { CodeBlock } from '@/components/shared/simple-code-block';

export const configSnippet = `# config/serialization.yaml
serialization:
  enabled: true
  ttlMs: 0 # no cache here; just showing structure
  exposeUnsetFields: false
  groups: ['public']
`;

export const httpSerialization = `import { Module, ConfigService } from '@nl-framework/core';
import { ConfigModule } from '@nl-framework/config';
import { Controller, Get, UseInterceptors } from '@nl-framework/http';
import { HttpSerializationInterceptor } from '@nl-framework/http';
import { SerializeOptions } from '@nl-framework/core';

export const HTTP_SERIALIZER = Symbol('serializer:http');

@Controller('/users')
@UseInterceptors(HTTP_SERIALIZER)
@SerializeOptions({ groups: ['public'] })
export class UsersController {
@Get('/')
list() {
return this.service.all(); // class instances are transformed to plain JSON
}

@Get('/admin')
@SerializeOptions({ groups: ['admin'] })
adminView() {
return this.service.all(); // per-handler overrides
}
}

@Module({
imports: [ConfigModule.forRoot()],
controllers: [UsersController],
providers: [
{
provide: HTTP_SERIALIZER,
inject: [ConfigService],
useFactory: (config: ConfigService<{ serialization: any }>) =>
new HttpSerializationInterceptor({
transformOptions: {
groups: config.get('serialization.groups', ['public']) as string[],
exposeUnsetFields: false,
},
}),
},
],
})
export class UsersModule {}`;

export const graphqlSerialization = `import { Module, ConfigService } from '@nl-framework/core';
import { ConfigModule } from '@nl-framework/config';
import { Resolver, Query } from '@nl-framework/graphql';
import { UseInterceptors } from '@nl-framework/http';
import { GraphqlSerializationInterceptor } from '@nl-framework/graphql';
import { SerializeOptions } from '@nl-framework/core';

export const GQL_SERIALIZER = Symbol('serializer:graphql');

@Resolver()
@UseInterceptors(GQL_SERIALIZER)
@SerializeOptions({ groups: ['public'] })
export class ReportsResolver {
@Query(() => [Report])
reports() {
return this.service.list(); // returns DTO instances
}
}

@Module({
imports: [ConfigModule.forRoot()],
providers: [
ReportsResolver,
{
provide: GQL_SERIALIZER,
inject: [ConfigService],
useFactory: (config: ConfigService<{ serialization: any }>) =>
new GraphqlSerializationInterceptor({
transformOptions: {
groups: config.get('serialization.groups', ['public']) as string[],
},
}),
},
],
})
export class ReportsModule {}`;

export const manualSerialize = `import { serialize, SerializeOptions } from '@nl-framework/core';

@SerializeOptions({ groups: ['public'] })
class UserView {
id!: string;
email!: string;
passwordHash!: string;
}

export function toPublicJson(user: UserView) {
  return serialize(user, { groups: ['public'] });
}`;

<article className="space-y-8">
      <div className="space-y-3">
        <Badge className="bg-purple-100 text-purple-900 dark:bg-purple-900/30 dark:text-purple-50">
          Techniques
        </Badge>
        <h1 className="text-4xl font-semibold tracking-tight">Serialization</h1>
        <div className="text-lg text-muted-foreground">
          Shape your JSON responses with class-transformer. Nael provides a shared `serialize()` helper,
          a `@SerializeOptions()` decorator for per-handler control, and HTTP/GraphQL interceptors that respect DI config.
          Streams, buffers, and `Response` objects are passed through unchanged.
        </div>
      </div>

      <section className="space-y-4" id="config">
        <h2 className="text-2xl font-semibold">Configure once</h2>
        <div className="text-muted-foreground">
          Keep serialization defaults in `ConfigModule` so interceptors can read groups or strategies without hardcoding.
          Use Symbols to register interceptors in the container and reuse across controllers or resolvers.
        </div>
        <CodeBlock code={configSnippet} title="config/serialization.yaml" />
      </section>

      <section className="space-y-4" id="http">
        <h2 className="text-2xl font-semibold">HTTP responses</h2>
        <div className="text-muted-foreground">
          Attach `HttpSerializationInterceptor` globally or per-controller. Combine with `@SerializeOptions()`
          to set `class-transformer` groups or naming strategies per handler.
        </div>
        <CodeBlock code={httpSerialization} title="DI-friendly HTTP serialization" />
      </section>

      <section className="space-y-4" id="graphql">
        <h2 className="text-2xl font-semibold">GraphQL results</h2>
        <div className="text-muted-foreground">
          Wrap resolvers with `GraphqlSerializationInterceptor` to convert DTO instances into plain objects before they hit Apollo.
          Skip primitives automatically; only objects/arrays are transformed.
        </div>
        <CodeBlock code={graphqlSerialization} title="GraphQL serialization" />
      </section>

      <section className="space-y-4" id="manual">
        <h2 className="text-2xl font-semibold">Manual helpers</h2>
        <div className="text-muted-foreground">
          Use `serialize()` directly in jobs or microservices when you need the same rules outside HTTP/GraphQL.
          Decorate classes with `@SerializeOptions()` to keep group-aware transforms close to the DTO.
        </div>
        <CodeBlock code={manualSerialize} title="serialize() utility" />
      </section>

      <section className="space-y-3" id="tips">
        <h2 className="text-2xl font-semibold">Best practices</h2>
        <ul className="list-disc space-y-2 pl-6 text-muted-foreground">
          <li>Prefer DTO classes with <code>groups</code> to hide fields (e.g., omit secrets for public responses).</li>
          <li>Let file/stream responses bypass serialization—return <code>Response</code>, <code>ReadableStream</code>, or buffers directly.</li>
          <li>Place serialization after caching when possible to store already-serialized payloads or wrap cache writes around the interceptor.</li>
          <li>Test serialization boundaries for nested relations to avoid circular structures; tweak <code>exposeDefaultValues</code> and strategy as needed.</li>
          <li>Pair with <Link className="text-primary underline" href="/docs/techniques/validation">Validation</Link> to keep DTOs consistent end-to-end.</li>
        </ul>
      </section>
    </article>
