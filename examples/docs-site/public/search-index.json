[
  {
    "title": "Middleware · Nael Platform",
    "description": "Learn how to use middleware for request processing, logging, authentication, and error handling in Nael applications.",
    "href": "/docs/middleware",
    "section": "middleware",
    "headings": [],
    "content": "import { MiddlewareHandler } from '@nl-framework/http'; const loggingMiddleware: MiddlewareHandler = async (ctx, next) => { console.log(\\`[\\${ctx.request.method}] \\${new URL(ctx.request.url).pathname}\\`); const response = await next(); console.log(\\`Response status: \\${response.status}\\`); return response; }; import { MiddlewareHandler } from '@nl-framework/http'; const requestTimingMiddleware: MiddlewareHandler = async (ctx, next) => { const started = Date.now(); try { const response = await next(); const elapsed = Date.now() - started; console.log('Request completed', { method: ctx.request.method, path: new URL(ctx.request.url).pathname, status: response.status, elapsedMs: elapsed, }); return response; } catch (error) { const elapsed = Date.now() - started; console.error('Request failed', { method: ctx.request.method, path: new URL(ctx.request.url).pathname, elapsedMs: elapsed, error, }); throw error; } }; import { NaelFactory } from '@nl-framework/platform'; const app = await NaelFactory.create(AppModule); const httpApp = app.getHttpApplication(); if (httpApp) { httpApp.use(loggingMiddleware); httpApp.use(requestTimingMiddleware); } await app.listen({ http: 3000 }); import { createHttpApplication } from '@nl-framework/http'; const app = await createHttpApplication(AppModule, { port: 3000, middleware: [ loggingMiddleware, requestTimingMiddleware, ], }); await app.listen(); import { MiddlewareHandler } from '@nl-framework/http'; const corsMiddleware: MiddlewareHandler = async (ctx, next) => { // Handle preflight requests if (ctx.request.method === 'OPTIONS') { return new Response(null, { status: 204, headers: { 'Access-Control-Allow-Origin': '\\*', 'Access-Control-Allow-Methods': 'GET, POST, PUT, DELETE, PATCH, OPTIONS', 'Access-Control-Allow-Headers': 'Content-Type, Authorization', 'Access-Control-Max-Age': '86400', }, }); } const response = await next(); // Add CORS headers to the response const headers = new Headers(response.headers); headers.set('Access-Control-Allow-Origin', '\\*'); headers.set('Access-Control-Allow-Methods', 'GET, POST, PUT, DELETE, PATCH, OPTIONS'); headers.set('Access-Control-Allow-Headers', 'Content-Type, Authorization'); return new Response(response.body, { status: response.status, statusText: response.statusText, headers, }); }; import { MiddlewareHandler } from '@nl-framework/http'; const authMiddleware: MiddlewareHandler = async (ctx, next) => { const authHeader = ctx.request.headers.get('Authorization'); if (!authHeader || !authHeader.startsWith('Bearer ')) { return new Response( JSON.stringify({ error: 'Unauthorized' }), { status: 401, headers: { 'Content-Type': 'application/json' }, } ); } const token = authHeader.substring(7); try { // Validate token here const user = await validateToken(token); // Attach user to context (would need custom context extension) // For now, continue to next middleware return await next(); } catch (error) { return new Response( JSON.stringify({ error: 'Invalid token' }), { status: 401, headers: { 'Content-Type': 'application/json' }, } ); } }; import { MiddlewareHandler } from '@nl-framework/http'; const requestIdMiddleware: MiddlewareHandler = async (ctx, next) => { const requestId = crypto.randomUUID(); const response = await next(); const headers = new Headers(response.headers); headers.set('X-Request-ID', requestId); return new Response(response.body, { status: response.status, statusText: response.statusText, headers, }); }; import { MiddlewareHandler } from '@nl-framework/http'; const compressionMiddleware: MiddlewareHandler = async (ctx, next) => { const response = await next(); const acceptEncoding = ctx.request.headers.get('Accept-Encoding') || ''; if (!acceptEncoding.includes('gzip')) { return response; } // Only compress JSON responses const contentType = response.headers.get('Content-Type') || ''; if (!contentType.includes('application/json')) { return response; } const body = await response.text(); const compressed = await Bun.gzipSync(Buffer.from(body)); const headers = new Headers(response.headers); headers.set('Content-Encoding', 'gzip'); headers.set('Content-Length', compressed.length.toString()); return new Response(compressed, { status: response.status, statusText: response.statusText, headers, }); }; import { MiddlewareHandler } from '@nl-framework/http'; const errorHandlingMiddleware: MiddlewareHandler = async (ctx, next) => { try { return await next(); } catch (error) { console.error('Unhandled error:', error); if (error instanceof ValidationError) { return new Response( JSON.stringify({ error: 'Validation failed', details: error.details, }), { status: 400, headers: { 'Content-Type': 'application/json' }, } ); } if (error instanceof NotFoundError) { return new Response( JSON.stringify({ error: 'Resource not found' }), { status: 404, headers: { 'Content-Type': 'application/json' }, } ); } return new Response( JSON.stringify({ error: 'Internal server error' }), { status: 500, headers: { 'Content-Type': 'application/json' }, } "
  },
  {
    "title": "Interceptors - NL Framework",
    "description": "Learn how to extend request/response behavior with interceptors in NL Framework.",
    "href": "/docs/interceptors",
    "section": "interceptors",
    "headings": [],
    "content": "import { Injectable } from '@nl-framework/core'; import { CallHandler, HttpInterceptor, HttpExecutionContext } from '@nl-framework/http'; @Injectable() export class LoggingInterceptor implements HttpInterceptor { async intercept(context: HttpExecutionContext, next: CallHandler) { const start = Date.now(); console.log('Before handler', context.getRoute().handlerName); const result = await next.handle(); console.log('After handler', Date.now() - start, 'ms'); return result; } } import { Controller, Get, UseInterceptors } from '@nl-framework/http'; @Controller('/reports') @UseInterceptors(LoggingInterceptor) export class ReportsController { @Get() async list() { return { reports: [] }; } @Get('/daily') @UseInterceptors(RequestTimingInterceptor) daily() { return { status: 'ok' }; } } import { InterceptorFunction } from '@nl-framework/http'; export const CacheInterceptor: InterceptorFunction = async (context, next) => { const cacheKey = context.getRoute().controller?.name + ':' + context.getRequest().url; const cached = await context.getContainer().resolve(CacheStore).get(cacheKey); if (cached) { return new Response(JSON.stringify(cached), { headers: { 'content-type': 'application/json' }, }); } const result = await next.handle(); await context.getContainer().resolve(CacheStore).set(cacheKey, result); return result; }; @Controller('/inventory') export class InventoryController { @Get() @UseInterceptors(CacheInterceptor) list() { return this.service.all(); } } import { registerHttpInterceptor } from '@nl-framework/http'; registerHttpInterceptor(LoggingInterceptor); const app = await createHttpApplication(AppModule, { port: 3000 }); await app.listen(); import { ObjectType, Field } from '@nl-framework/graphql'; import { Resolver, Query } from '@nl-framework/graphql'; import { UseInterceptors } from '@nl-framework/http'; import { GraphqlCallHandler, GraphqlInterceptor, registerGraphqlInterceptor, } from '@nl-framework/graphql'; class EnvelopeInterceptor implements GraphqlInterceptor { async intercept(\\_context: unknown, next: GraphqlCallHandler) { const result = await next.handle(); return { data: result }; } } registerGraphqlInterceptor(EnvelopeInterceptor); @ObjectType() class Report { @Field() message!: string; } @Resolver(() => Report) @UseInterceptors(EnvelopeInterceptor) export class ReportResolver { @Query(() => Report) stats() { return { message: 'report' }; } } import { CallHandler, HttpExecutionContext, HttpInterceptor } from '@nl-framework/http'; export class EnvelopeInterceptor implements HttpInterceptor { async intercept(_context: HttpExecutionContext, next: CallHandler) { const result = await next.handle(); return { data: result, at: new Date().toISOString() }; } } @Controller('/users') @UseInterceptors(EnvelopeInterceptor) export class UsersController { @Get() list() { return [{ id: 1, email: 'ada@example.com' }]; } } import { HttpInterceptor, CallHandler, HttpExecutionContext } from '@nl-framework/http'; import { ApplicationException } from '@nl-framework/core'; export class ErrorsInterceptor implements HttpInterceptor { async intercept(_context: HttpExecutionContext, next: CallHandler) { try { return await next.handle(); } catch (error) { if (error instanceof ApplicationException) { return new Response( JSON.stringify({ code: error.code, message: error.message }), { status: 502, headers: { 'content-type': 'application/json' } }, ); } throw error; } } } import { HttpInterceptor, HttpExecutionContext, CallHandler } from '@nl-framework/http'; export class TimeoutInterceptor implements HttpInterceptor { constructor(private readonly timeoutMs = 5000) {} async intercept(\\_context: HttpExecutionContext, next: CallHandler) { const controller = new AbortController(); const timeout = setTimeout(() => controller.abort(), this.timeoutMs); try { return await Promise.race([ next.handle(), new Promise((_, reject) => controller.signal.addEventListener('abort', () => reject(new Error('Request timeout')))), ]); } finally { clearTimeout(timeout); } } } Interceptors wrap the execution of your route handlers, giving you a single place to run code before and after controllers execute. Use them for logging, response mapping, caching, exception translation, or any cross-cutting behavior. Key pipeline order: middleware ➜ guards ➜ interceptors ➜ pipes ➜ handler ➜ filters. Interceptors share the same HttpExecutionContext as guards and can short-circuit requests by returning their own Response objects. Interceptors implement the HttpInterceptor interface. They receive the execution context and a CallHandler that invokes the next interceptor (or ultimately the route handler). Use the @UseInterceptors() decorator to attach interceptors to controllers or individual handlers. Order matters—the first decorator argument wraps everything that follows. For lightweight cases you can pass an InterceptorFunction. Functional interceptors are great for caching or analytics because they require no class registration. Call registerHttpInterc"
  },
  {
    "title": "Lifecycle events · Nael Platform",
    "description": "Use OnModuleInit, OnModuleDestroy, and bootstrap hooks to manage resources cleanly in Nael modules.",
    "href": "/docs/fundamentals/lifecycle-events",
    "section": "fundamentals",
    "headings": [],
    "content": "import { Injectable, OnModuleInit } from '@nl-framework/core'; import { createClient } from 'redis'; @Injectable() export class CacheService implements OnModuleInit { private client = createClient({ url: process.env.REDIS_URL }); async onModuleInit() { await this.client.connect(); } async get(key: string) { return this.client.get(key); } } import { Injectable, OnModuleDestroy } from '@nl-framework/core'; import { Kafka } from 'kafkajs'; @Injectable() export class EventBus implements OnModuleDestroy { private readonly kafka = new Kafka({ clientId: 'app', brokers: ['localhost:9092'] }); private producer = this.kafka.producer(); async onModuleInit() { await this.producer.connect(); } async onModuleDestroy() { await this.producer.disconnect(); } } import { createHttpApplication } from '@nl-framework/http'; const app = await createHttpApplication(AppModule, { port: 3000 }); const server = await app.listen(); process.on('SIGTERM', async () => { await app.close(); process.exit(0); }); import { Module, Provider } from '@nl-framework/core'; @Module({ providers: [CacheService, StatsService], bootstrap: [CacheService], }) export class MetricsModule {} Providers in Nael can perform setup and teardown logic through lifecycle interfaces. Knowing when these callbacks fire keeps long-lived connections healthy, prevents resource leaks, and allows modules to prepare caches before the first request hits. Implement OnModuleInit to run code immediately after the container creates your provider. This is ideal for establishing database connections, warming caches, or scheduling background tasks that should start only once. The container awaits the promise returned by onModuleInit, so make sure long-running work (migrations, hydration) remains bounded to avoid delaying the entire application. Implement OnModuleDestroy to release external resources during shutdown. The container calls every registered handler as part of ApplicationContext.close() and platform close() methods. Always wrap network cleanup in try/catch to log failures—shutdown should not crash the process. Modules can force specific providers to instantiate during startup via the bootstrap array in @Module metadata. This is useful when the provider exposes a background loop or needs to populate shared state before handling traffic. Bootstrapped providers still receive onModuleInit callbacks; the array merely guarantees they are resolved eagerly. HTTP and GraphQL applications expose close() methods that call the underlying ApplicationContext.close(). Invoke them during process shutdown signals so OnModuleDestroy handlers run and servers stop accepting connections gracefully."
  },
  {
    "title": "Dynamic modules · Nael Platform",
    "description": "Design modules that accept configuration via register/registerAsync so features can be reused across applications.",
    "href": "/docs/fundamentals/dynamic-modules",
    "section": "fundamentals",
    "headings": [],
    "content": "import { DynamicModule, Module } from '@nl-framework/core'; type MailerModuleOptions = { transport: string; defaults?: Record<string, unknown>; }; @Module({}) export class MailerModule { static register(options: MailerModuleOptions): DynamicModule { return { module: MailerModule, providers: [ MailerService, { provide: MAILER_OPTIONS, useValue: options }, ], exports: [MailerService], }; } } // feature/users/users.module.ts import { Module } from '@nl-framework/core'; @Module({ imports: [ MailerModule.register({ transport: 'smtp://send.example.com', defaults: { from: 'support@example.com' }, }), ], providers: [UsersService], }) export class UsersModule {} import { DynamicModule, Module } from '@nl-framework/core'; import { ConfigModule, ConfigService } from '@nl-framework/config'; type MailerModuleAsyncOptions = { imports?: DynamicModule[]; inject?: any[]; useFactory: (...args: any[]) => Promise<MailerModuleOptions> | MailerModuleOptions; }; @Module({}) export class MailerModule { static registerAsync(options: MailerModuleAsyncOptions): DynamicModule { return { module: MailerModule, imports: options.imports ?? [], providers: [ MailerService, { provide: MAILER_OPTIONS, useFactory: options.useFactory, inject: options.inject ?? [], }, ], exports: [MailerService], }; } } // root module @Module({ imports: [ ConfigModule.forRoot({ isGlobal: true }), MailerModule.registerAsync({ imports: [ConfigModule], inject: [ConfigService], useFactory: async (config: ConfigService) => ({ transport: config.get('smtp.url'), defaults: { from: config.get('smtp.from') }, }), }), ], }) export class AppModule {} @Module({ imports: [MailerModule.register({ transport: 'smtp://...' })], exports: [MailerModule], }) export class MessagingSharedModule {} @Module({ imports: [MessagingSharedModule], }) export class NotificationsModule {} Dynamic modules expose a factory API&mdash;usually called register() or forRoot()&mdash;so consumers can configure providers on the fly. They are the building block for reusable libraries such as Config, Auth, or Scheduler. Return a DynamicModule object with the module, providers, and exports fields. The calling module decides the configuration, while your feature stays stateless. Feature modules import the configured version just like any other module. Each call to register() produces its own provider graph, so different features can point to different transports without interfering with each other. Use registerAsync()/forRootAsync() when you need to read environment variables, fetch secrets, or build the option object asynchronously. You can delegate to useFactory, useClass, or useExisting just like any other provider. If multiple feature modules need the same configuration (e.g., one SMTP transport), wrap the dynamic module in a shared module and export it. Downstream modules simply import the shared module to reuse the providers. This mirrors NestJS&rsquo;s forRoot()/forFeature() pattern and keeps your dependency graph explicit."
  },
  {
    "title": "Lazy-loading modules · Nael Platform",
    "description": "Load feature modules on demand with LazyModuleLoader and the ApplicationContext hooks.",
    "href": "/docs/fundamentals/lazy-loading",
    "section": "fundamentals",
    "headings": [],
    "content": "import { LazyModuleLoader } from '@nl-framework/core'; import { createHttpApplication } from '@nl-framework/http'; const http = await createHttpApplication(AppModule, { port: 0 }); const loader = await http.get(LazyModuleLoader); await loader.load(async () => (await import('./reports/reports.module')).ReportsModule); import { Application } from '@nl-framework/core'; const app = new Application(); const context = await app.bootstrap(AppModule); const unsubscribe = context.addModuleLoadListener(({ module, controllers }) => { console.log('Loaded module:', module.name, 'controllers:', controllers.length); }); await context.loadModule(ReportsModule); unsubscribe(); import { LazyModuleLoader } from '@nl-framework/core'; import { GraphqlApplication } from '@nl-framework/graphql'; const graphql = await createGraphqlApplication(AppModule); const loader = await graphql.get(LazyModuleLoader); await loader.load(() => import('./billing/billing.module')); // Next request sees the rebuilt schema automatically. Skip eager initialization for heavy features and load them only when a tenant, route, or job actually needs them. Nael exposes a Reach for lazy loading when a feature pulls in expensive providers (ORM connections, external SDKs, giant resolvers) that only a subset of users require. Instead of bloating startup time, keep those modules on the shelf and register them just-in-time once you have enough context to know they are needed. Imagine a SaaS platform where only premium tenants can access the reporting suite. Instead of registering every reporting adapter and data warehouse client on startup, keep the module cold and let the first premium request trigger the load. Subsequent requests from that tenant get the warmed module instantly, while standard tenants never pay the cost. Tie the loader into your tenant resolution logic (guards, middleware, schedulers) and call loader.load(PremiumReportsModule) only when tenant.plan === 'premium'. This keeps memory predictable and shortens boot time for the common case without removing capabilities for customers who need them. The LazyModuleLoader is injectable from any application context (core, HTTP, GraphQL, schedulers). Call load() with either a module class or a factory that performs a dynamic import. The loader registers the module, instantiates its providers, and emits a load event so other parts of the system can react. The loader understands default exports as well, so returning the raw import() promise works if your module file exports a default class. The ApplicationContext now exposes loadModule() and addModuleLoadListener(). Use them to wire up your own bookkeeping (analytics, cache warmers, telemetry) whenever new modules join the container. Listeners return an unsubscribe function. They run after the module&apos;s providers, controllers, and bootstrap tokens are fully instantiated. Built-in platforms already listen for module load events so routes, resolvers, and guards stay in sync: HTTP : new controllers are registered with the router immediately—no need to restart the server. Custom middleware can lazily grab services from the same context ID. GraphQL : when a module adds resolvers, the schema is invalidated and rebuilt on the next request so clients see the new queries and mutations without downtime."
  },
  {
    "title": "Custom providers · Nael Platform",
    "description": "Understand provider tokens, alternative implementations, and factory patterns so you can adapt the IoC container to any integration.",
    "href": "/docs/fundamentals/custom-providers",
    "section": "fundamentals",
    "headings": [],
    "content": "import { Inject, Injectable, Module } from '@nl-framework/core'; type CacheClient = { get(key: string): Promise<string | undefined>; set(key: string, value: string): Promise<void>; }; export const CACHE_TOKEN = Symbol('CACHE_CLIENT'); @Injectable() export class CacheService { constructor(@Inject(CACHE_TOKEN) private readonly cache: CacheClient) {} async getOrSet(key: string, compute: () => Promise<string>) { const cached = await this.cache.get(key); if (cached) { return cached; } const value = await compute(); await this.cache.set(key, value); return value; } } @Module({ providers: [ { provide: CACHE_TOKEN, useValue: createCacheClient(), // imagine this establishes a Redis connection }, CacheService, ], exports: [CACHE_TOKEN, CacheService], }) export class CacheModule {} import { Injectable, Module } from '@nl-framework/core'; abstract class MailClient { abstract send(to: string, subject: string, body: string): Promise<void>; } @Injectable() class SendgridMailer implements MailClient { async send(to: string, subject: string, body: string) {/* call vendor API */} } @Injectable() class LocalMailer implements MailClient { async send(to: string, subject: string, body: string) { console.log('mail', { to, subject, body }); } } const mailerProvider = { provide: MailClient, useClass: process.env.NODE_ENV === 'development' ? LocalMailer : SendgridMailer, }; @Module({ providers: [mailerProvider], exports: [MailClient], }) export class NotificationsModule {} import { Module } from '@nl-framework/core'; const databaseProvider = { provide: 'DB_CONNECTION', useFactory: async (config: ConfigService, logger: Logger) => { const options = config.get('database'); const connection = await createConnection(options); logger.log('[db] connected'); return connection; }, inject: [ConfigService, Logger], }; @Module({ providers: [databaseProvider], exports: ['DB_CONNECTION'], }) export class DatabaseModule {} import { Inject, Injectable, Module, forwardRef } from '@nl-framework/core'; @Injectable() export class AccountsService { constructor(private readonly payments: PaymentsService) {} } @Injectable() export class PaymentsService { constructor( @Inject(forwardRef(() => AccountsService)) private readonly accounts: AccountsService, ) {} } @Module({ providers: [AccountsService, PaymentsService], }) export class BillingModule {} Everything in Nael is just a provider resolved by a token. By shaping those tokens yourself—value objects, alternate classes, or factories—you can plug in third-party SDKs, swap implementations per environment, or stub dependencies in tests without rewriting consumers. A provider is either a class marked with @Injectable() or an object literal following the Provider union (ClassProvider, ValueProvider, or FactoryProvider). Value providers shine when you already have an instance—like a database client or preconfigured SDK—and want Nael&rsquo;s container to share it everywhere. Prefer Symbol tokens for cross-package safety, then inject them with @Inject(). Exporting both the token and the consumer class lets downstream modules re-use the same instance without knowing how it is created. Sometimes you care about the abstraction (an interface or abstract class) rather than a concrete implementation. useClass lets you bind a token to a class at registration time, so the consumer keeps the same constructor signature while the framework decides which implementation to instantiate. This pattern is perfect for swapping real infrastructure with fakes in development or testing. You can also redeclare the provider inside a testing module to override it temporarily. Factories run after the container resolves anything listed in inject. They may return values synchronously or asynchronously, which makes them ideal for bootstrapping SDKs that need configuration, logging, or other providers. Nael will await the Promise before exposing the resulting instance to the rest of the application. You can combine factories with module exports to share expensive singletons (database pools, caches) without leaking implementation details. For advanced cases, factories can even emit different values per scope by inspecting request-specific data. When two providers depend on each other, wrap the token in forwardRef(() =&gt; Token). The container postpones evaluation until both classes are defined, avoiding the dreaded undefined dependency issues. Use forward references sparingly—they are a smell that the collaboration might be extracted into a third provider—but they unblock legitimate scenarios such as domain services reacting to each other&rsquo;s events."
  },
  {
    "title": "Async providers · Nael Platform",
    "description": "Configure modules and tokens that depend on asynchronous work using useFactory, useClass, and useExisting patterns.",
    "href": "/docs/fundamentals/async-providers",
    "section": "fundamentals",
    "headings": [],
    "content": "import { Module } from '@nl-framework/core'; import { ConfigModule, ConfigService } from '@nl-framework/config'; import { DatabaseModule } from '@acme/database'; // imagine a feature module that exposes forRootAsync @Module({ imports: [ ConfigModule.forRoot({ isGlobal: true }), DatabaseModule.forRootAsync({ inject: [ConfigService], useFactory: async (config: ConfigService) => ({ url: config.get('database.url'), ssl: config.get('database.sslEnabled'), maxConnections: 10, }), }), ], }) export class AppModule {} import { Injectable } from '@nl-framework/core'; import type { BetterAuthModuleOptions, BetterAuthOptionsFactory } from '@nl-framework/auth'; import { BetterAuthModule } from '@nl-framework/auth'; import { ConfigService } from '@nl-framework/config'; @Injectable() class AuthEnvService implements BetterAuthOptionsFactory { constructor(private readonly config: ConfigService) {} async createBetterAuthOptions(): Promise<BetterAuthModuleOptions> { return { projectId: this.config.get('auth.projectId'), secret: await this.config.getSecret('auth.secret'), }; } } @Module({ imports: [ BetterAuthModule.registerAsync({ useClass: AuthEnvService, imports: [ConfigModule], }), ], }) export class AuthModule {} @Module({ providers: [AuthEnvService], exports: [AuthEnvService], }) export class SharedConfigModule {} @Module({ imports: [ SharedConfigModule, BetterAuthModule.registerAsync({ useExisting: AuthEnvService, }), ], }) export class AuthModule {} @Module({ imports: [CacheModule.forRootAsync({ useFactory: async () => ({ url: process.env.REDIS_URL! }) })], }) export class AppModule implements OnModuleInit { constructor(private readonly cache: CacheService) {} async onModuleInit() { await this.cache.ping(); } } Not every dependency is ready the moment your module file executes. Async providers let Nael wait for Promises, wire dependencies first, and share the resolved value after bootstrapping—perfect for database pools, SDK clients, or secrets loaded from external services. The most flexible form is useFactory. List whatever providers you need inside inject, perform async work, and return either the provider value or the options object a module needs. Nael will await the Promise before exposing the dependency downstream. Keep factory functions side-effect free—no global state—and push configuration concerns into dedicated services to simplify testing. Many built-in modules (Config, BetterAuth, ORM, Scheduler) expose an OptionsFactory interface. Implement it when you prefer an injectable class over an inline function. Nael instantiates the class once (respecting scope) and calls the factory method. Classes can leverage constructor injection, caching, or memoization. They also compose nicely with testing modules that override the provider. If a module already provides the correct factory class, useExisting prevents duplicate instances. Nael will reference the pre-registered token instead of creating a new class. This pattern excels in monorepos where multiple features need the same config loader. Export the factory class once, then point to it via useExisting everywhere else. Async providers delay application bootstrap until they resolve. You can safely run sanity checks in onModuleInit or onApplicationBootstrap knowing the dependencies are ready. When a provider must refresh periodically (e.g., rotating secrets), create a scoped factory or schedule refresh logic after the app starts."
  },
  {
    "title": "Execution context · Nael Platform",
    "description": "Understand how Nael propagates context IDs across HTTP, GraphQL, and custom workloads for scoped providers.",
    "href": "/docs/fundamentals/execution-context",
    "section": "fundamentals",
    "headings": [],
    "content": "import { createHttpApplication } from '@nl-framework/http'; import { Controller, Get, Injectable, Scope } from '@nl-framework/core'; @Injectable({ scope: Scope.REQUEST }) class RequestMetadata { readonly startedAt = Date.now(); url?: string; } @Controller('health') class HealthController { constructor(private readonly metadata: RequestMetadata) {} @Get() status() { return { ok: true, receivedAt: this.metadata.startedAt, url: this.metadata.url, }; } } const app = await createHttpApplication(AppModule); await app.listen(); import { MiddlewareHandler } from '@nl-framework/http'; import { RequestContext } from '@nl-framework/http'; export const tenantResolver: MiddlewareHandler = async (ctx, next) => { const tenantId = ctx.request.headers.get('x-tenant-id'); const tenant = await ctx.container.resolve(TenantContext); tenant.set(tenantId); return next(); }; import { Application, Scope, Injectable } from '@nl-framework/core'; @Injectable({ scope: Scope.REQUEST }) class JobState { id?: string; } const app = new Application(); const context = await app.bootstrap(AppModule); const jobId = context.createContextId('nightly-report'); try { const state = await context.get(JobState, { contextId: jobId }); state.id = 'job-42'; await runReport(state); } finally { context.releaseContext(jobId); } import { Injectable, ModuleRef } from '@nl-framework/core'; @Injectable() class ReportRunner { constructor(private readonly moduleRef: ModuleRef) {} async execute() { const mailer = await this.moduleRef.resolve(MailerService, { strict: false }); await mailer.send(); } } The Nael container tracks every unit of work using a context ID . Request-scoped providers, interceptors, and guards all look up that ID so cross-cutting data (tenant IDs, trace info, auth state) stays isolated. This page explains how the context flows through HTTP and GraphQL platforms and how you can create custom scopes for background jobs or schedulers. When you call createHttpApplication() or createGraphqlApplication(), the platform allocates a fresh context ID per incoming request, resolves request-scoped providers under that ID, and disposes the context after the response. You can safely inject Scope.REQUEST services anywhere in the call tree. You can still mutate the scoped service inside middleware or guards (see below) and downstream controllers will observe the same instance. Inject the request-scoped service inside middleware, guards, or interceptors via ctx.container.resolve(). Whatever you write to that instance is visible later in controllers, resolvers, or services resolved from the same context ID. Guards and interceptors can use the same pattern. Under the hood, the platform passes the active context ID into the container whenever it resolves a dependency. Outside HTTP/GraphQL—you might be in a scheduler, CLI command, or background worker—you can still get request-like scoping. Leverage the ApplicationContext to create, use, and release context IDs manually. Always call releaseContext() in a finally block so the container can dispose transient instances and avoid memory leaks. If you need to resolve dependencies lazily (e.g., inside a method rather than the constructor), inject ModuleRef. Calls to resolve() reuse the active context ID by default, so request-scoped providers remain consistent even when you defer their creation."
  },
  {
    "title": "Injection scopes · Nael Platform",
    "description": "Understand singleton, request, and transient lifecycles in the Nael IoC container.",
    "href": "/docs/fundamentals/injection-scopes",
    "section": "fundamentals",
    "headings": [],
    "content": "import { Injectable } from '@nl-framework/core'; @Injectable() export class FeatureFlagService { private cache = new Map<string, boolean>(); isEnabled(flag: string) { return this.cache.get(flag) ?? false; } } import { Injectable, Scope } from '@nl-framework/core'; import { RequestContext } from '@nl-framework/http'; @Injectable({ scope: Scope.REQUEST }) export class RequestLogger { constructor(private readonly ctx: RequestContext) {} log(message: string) { console.log('[' + this.ctx.request.url + ']', message); } } import { Injectable, Scope, Inject } from '@nl-framework/core'; import { randomUUID } from 'node:crypto'; @Injectable({ scope: Scope.TRANSIENT }) export class JobIdFactory { readonly id = randomUUID(); } @Injectable() export class JobsService { constructor(@Inject(JobIdFactory) private readonly jobIdFactory: JobIdFactory) {} run() { return this.jobIdFactory.id; } } import { Injectable, Scope } from '@nl-framework/core'; import { GraphqlExecutionContext } from '@nl-framework/graphql'; @Injectable({ scope: Scope.REQUEST }) export class TenantContext { private tenantId?: string; setFromExecution(ctx: GraphqlExecutionContext) { this.tenantId = ctx.getContext().tenantId; } getId() { return this.tenantId; } } const app = await createHttpApplication(AppModule); const appContext = app.getApplicationContext(); const contextId = appContext.createContextId('job-42'); try { const tenant = await appContext.get(TenantContext, { contextId }); tenant.setFromExecution(jobContext); await jobRunner.execute(tenant); } finally { appContext.releaseContext(contextId); } Providers can live for the entire application, per incoming request, or be created every time they are injected. Choosing the right scope keeps expensive dependencies cached while still giving you access to per-request metadata when you need it. Without extra options, every @Injectable() is a singleton. It is instantiated once during application bootstrap and shared with all consumers. Use this for stateless services, caches, config readers, or clients that should be reused. Be careful not to store request-specific data in singletons. Prefer method arguments or scoped providers for that data. Set scope: Scope.REQUEST to create a new instance per HTTP or GraphQL request. The container ties the lifecycle to the current execution context so you can access headers, user info, or trace IDs without manual plumbing. Request-scoped services can inject other request-scoped or singleton providers. Avoid injecting them into singletons unless you also mark the consuming provider as request-scoped, otherwise Nael will throw a circular scope error. Transient providers are created every time they are injected. They never share state between injections, making them ideal for lightweight value objects, builders, or utilities that should produce a fresh instance per use. Because transient providers can fan out quickly, keep them cheap to create. They can inject singletons freely. Request scope also applies to GraphQL resolvers, scheduled jobs, and any custom context you establish via the core container. For advanced scenarios, you can create your own context IDs to isolate providers per unit of work. To populate data, hook into the relevant execution context (HTTP guards, GraphQL interceptors, schedulers, etc.) and set values on the scoped service."
  },
  {
    "title": "Module reference · Nael Platform",
    "description": "Use ModuleRef to resolve providers dynamically, create scoped instances, and interact with module-scoped injectors.",
    "href": "/docs/fundamentals/module-reference",
    "section": "fundamentals",
    "headings": [],
    "content": "import { Injectable } from '@nl-framework/core'; import { ModuleRef } from '@nl-framework/core'; @Injectable() export class ReportsService { constructor(private readonly moduleRef: ModuleRef) {} async sendWeeklyReport() { const email = await this.moduleRef.resolve(EmailService); await email.send('ops@example.com', 'Weekly status', '...'); } } const cache = await this.moduleRef.resolve(CacheService, { strict: true, }); // Throws if CacheService is not part of the current module tree. const exporter = await this.moduleRef.create(ExporterService); await exporter.export(); // create() bypasses the shared singleton and gives you a fresh instance. const billingModule = this.moduleRef.get('BillingModule', { strict: false }); const billingService = billingModule.get(BillingService); ModuleRef exposes the underlying injector so you can look up providers outside of constructor injection. Use it sparingly for dynamic workflows, plug-in systems, or bridging circular dependencies. Call moduleRef.resolve(Token) to retrieve a provider using the same injection graph Nael builds at bootstrap. The promise resolves once the provider is ready; if it was request-scoped, it will honor the current context. By default, resolve() searches the entire module graph. Pass strict: true to restrict the lookup to the current module (and its providers). This is useful for enforcing encapsulation. Use moduleRef.create() when you need a throwaway instance that should not be cached by the container. Nael will construct the provider and resolve its dependencies, but ownership stays with the caller. When you need to traverse module boundaries manually, moduleRef.get() accepts strings, class tokens, or symbols. Combine it with strict: false to reach exported providers from imported modules. Prefer constructor injection or explicit exports whenever possible; ModuleRef is a powerful escape hatch but can reduce clarity if overused."
  },
  {
    "title": "Circular dependencies · Nael Platform",
    "description": "Break circular references between providers and modules using forwardRef, ModuleRef, and lazy resolution patterns.",
    "href": "/docs/fundamentals/circular-dependency",
    "section": "fundamentals",
    "headings": [],
    "content": "import { Inject, Injectable, forwardRef } from '@nl-framework/core'; @Injectable() export class UsersService { constructor( @Inject(forwardRef(() => PaymentsService)) private readonly payments: PaymentsService, ) {} async createUser() { await this.payments.provisionWallet(); } } @Injectable() export class PaymentsService { constructor(private readonly users: UsersService) {} async provisionWallet() {/* ... */} } import { Module, forwardRef } from '@nl-framework/core'; @Module({ providers: [UsersService], exports: [UsersService], imports: [forwardRef(() => PaymentsModule)], }) export class UsersModule {} @Module({ providers: [PaymentsService], exports: [PaymentsService], imports: [forwardRef(() => UsersModule)], }) export class PaymentsModule {} import { Injectable } from '@nl-framework/core'; import { ModuleRef } from '@nl-framework/core'; @Injectable() export class ReportsService { constructor(private readonly moduleRef: ModuleRef) {} async run() { const exporter = await this.moduleRef.resolve(ExporterService, { strict: false }); return exporter.export(); } } import { Injectable, Inject, forwardRef, OnModuleInit } from '@nl-framework/core'; @Injectable() export class NotificationsService implements OnModuleInit { private emailService!: EmailService; constructor(@Inject(forwardRef(() => EmailService)) private readonly email: EmailService) {} onModuleInit() { this.emailService = this.email; } } @Injectable() export class EmailService { constructor(private readonly notifications: NotificationsService) {} } Sometimes two services need each other. Nael can resolve those cycles when you explicitly signal them with helpers like forwardRef or by lazily fetching a provider from ModuleRef. This page covers the common escape hatches and when to reach for them. Wrap the token passed to @Inject() in forwardRef() so the container evaluates the reference only after both classes are defined. This keeps constructor injection intact while avoiding undefined errors at runtime. Consider whether the cycle reveals a tighter coupling than necessary. Sometimes extracting a shared interface or domain event eliminates the loop. Modules can also depend on each other. When both need to import the other&rsquo;s exports, wrap the module reference in forwardRef inside the imports array. Nael will inline a thunk that resolves to the actual module once it is defined. ModuleRef lets you resolve providers on demand, outside of the constructor. Use this when eager injection would create a cycle but the dependency is only needed for specific code paths. Passing '} allows looking up tokens from imported modules. Prefer explicit module exports to keep ownership clear. When you must reference a provider immediately after construction, you can inject a forward reference and assign it during lifecycle hooks such as onModuleInit. It&rsquo;s more verbose, but it keeps constructors minimal."
  },
  {
    "title": "Providers · Nael Platform",
    "description": "Learn about providers, dependency injection, and service management in Nael Platform.",
    "href": "/docs/providers",
    "section": "providers",
    "headings": [],
    "content": "import { Injectable } from '@nl-framework/core'; @Injectable() export class UsersService { private readonly users: User[] = []; create(user: User) { this.users.push(user); } findAll(): User[] { return this.users; } findOne(id: number): User { return this.users.find(user => user.id === id); } } import { Controller, Get, Post, Body, Param } from '@nl-framework/http'; @Controller('users') export class UsersController { constructor(private usersService: UsersService) {} @Post() async create(@Body() createUserDto: CreateUserDto) { this.usersService.create(createUserDto); } @Get() async findAll() { return this.usersService.findAll(); } @Get(':id') async findOne(@Param('id') id: string) { return this.usersService.findOne(+id); } } import { Injectable, Scope } from '@nl-framework/core'; @Injectable({ scope: Scope.REQUEST }) export class UsersService {} import { Injectable, Optional, Inject } from '@nl-framework/core'; @Injectable() export class HttpService { constructor(@Optional() @Inject('HTTP_OPTIONS') private httpOptions) {} } import { Injectable, Inject } from '@nl-framework/core'; @Injectable() export class HttpService { @Inject('HTTP_OPTIONS') private readonly httpOptions; } import { Module } from '@nl-framework/core'; @Module({ controllers: [UsersController], providers: [UsersService], }) export class UsersModule {} const connectionProvider = { provide: 'CONNECTION', useValue: connection, }; @Module({ providers: [connectionProvider], }) export class AppModule {} const configServiceProvider = { provide: ConfigService, useClass: process.env.NODE_ENV === 'development' ? DevelopmentConfigService : ProductionConfigService, }; @Module({ providers: [configServiceProvider], }) export class AppModule {} const connectionFactory = { provide: 'CONNECTION', useFactory: (optionsProvider: OptionsProvider) => { const options = optionsProvider.get(); return new DatabaseConnection(options); }, inject: [OptionsProvider], }; @Module({ providers: [connectionFactory], }) export class AppModule {} { provide: 'ASYNC_CONNECTION', useFactory: async () => { const connection = await createConnection(); return connection; }, } import { Module } from '@nl-framework/core'; @Module({ providers: [UsersService], exports: [UsersService], }) export class UsersModule {} Providers are a fundamental concept in Nael. Many of the basic classes may be treated as providers – services, repositories, factories, helpers, and so on. The main idea of a provider is that it can be injected as a dependency; this means objects can create various relationships with each other. Let&apos;s start by creating a simple UsersService. This service will be responsible for data storage and retrieval, and is designed to be used by the UsersController, so it&apos;s a good candidate to be defined as a provider. The @Injectable() decorator attaches metadata, which declares that UsersService is a class that can be managed by the Nael IoC container. This example also uses a User interface, which probably looks something like this: Nael is built around the strong design pattern commonly known as Dependency injection. We recommend reading a great article about this concept in the official Angular documentation. In Nael, thanks to TypeScript capabilities, it&apos;s extremely easy to manage dependencies because they are resolved just by type. In the example below, Nael will resolve the usersService by creating and returning an instance of UsersService (or, in the normal case of a singleton, returning the existing instance if it has already been requested elsewhere). This dependency is resolved and passed to your controller&apos;s constructor: Providers normally have a lifetime (&quot;scope&quot;) synchronized with the application lifecycle. When the application is bootstrapped, every dependency must be resolved, and therefore every provider has to be instantiated. Similarly, when the application shuts down, each provider will be destroyed. However, there are ways to make your provider lifetime request-scoped as well. Occasionally, you might have dependencies which do not necessarily have to be resolved. For instance, your class may depend on a configuration object, but if none is passed, the default values should be used. In such a case, the dependency becomes optional. In the example above, we are using the @Optional() decorator, which marks a dependency as optional. The technique we&apos;ve used so far is called constructor-based injection, as providers are injected via the constructor method. In some very specific cases, property-based injection might be useful. For instance, if your top-level class depends on either one or multiple providers, passing them all the way up by calling super() in sub-classes from the constructor can be very tedious. Now that we have defined a provider (UsersService), and we have a consumer of that service (UsersController), we need to register the service with Nael so that it can perform the injection. We do this by editing our module file and a"
  },
  {
    "title": "Installation · Nael Platform",
    "description": "Install Nael Platform from the monorepo or by selectively adding @nl-framework packages to your Bun workspace.",
    "href": "/docs/installation",
    "section": "installation",
    "headings": [],
    "content": "git clone git@github.com:Nael-Studio/nael-platform.git cd nael-platform bun install bun add @nl-framework/core @nl-framework/platform @nl-framework/http \\ @nl-framework/graphql @nl-framework/config bun add @nl-framework/microservices @nl-framework/scheduler`; export const linkCommand = `bun link ../nl-framework-v1/packages/core Clone the entire repo for every example or install only the packages you need. Each module lives under the @nl-framework scope and is published as native ES modules for Bun runtimes. Use bun run --cwd examples/basic-http start (swap folder names) to explore each scenario. Layer in @nl-framework/auth, @nl-framework/logger, or @nl-framework/orm as your service footprint grows. Every package exposes familiar forRoot() and forFeature() helpers just like NestJS. Add the async modules when you need Dapr-backed pub/sub or Bun Worker cron jobs. Install the Dapr CLI and run dapr init before starting examples/microservices . Working on the framework and a consuming app simultaneously? Link the local packages and the nl CLI will pick them up automatically. Repeat for @nl-framework/http, @nl-framework/graphql, and any other packages you iterate on. Ready to build something new? Jump back to the Getting Started guide or run nl new awesome-service to scaffold a fresh project."
  },
  {
    "title": "Exception Filters · Nael Platform",
    "description": "Learn how to use exception filters for centralized error handling and custom error responses in Nael applications.",
    "href": "/docs/exception-filters",
    "section": "exception-filters",
    "headings": [],
    "content": "import { ExceptionFilter, HttpException } from '@nl-framework/http'; import type { RequestContext } from '@nl-framework/http'; export class HttpExceptionFilter implements ExceptionFilter { async catch(exception: Error, context: RequestContext): Promise<Response> { if (exception instanceof HttpException) { return new Response( JSON.stringify({ statusCode: exception.status, message: exception.message, timestamp: new Date().toISOString(), path: new URL(context.request.url).pathname, }), { status: exception.status, headers: { 'Content-Type': 'application/json' }, } ); } // Handle other exceptions return new Response( JSON.stringify({ statusCode: 500, message: 'Internal Server Error', timestamp: new Date().toISOString(), }), { status: 500, headers: { 'Content-Type': 'application/json' }, } ); } } import { registerExceptionFilters } from '@nl-framework/http'; // Register during application bootstrap registerExceptionFilters(new HttpExceptionFilter()); import { HttpException } from '@nl-framework/http'; import { Controller, Get, Post, Body, Param } from '@nl-framework/http'; @Controller('/posts') export class PostsController { @Get('/:id') async findOne(@Param('id') id: string) { const post = await this.findPostById(id); if (!post) { throw HttpException.notFound(\\`Post with ID \\${id} not found\\`); } return post; } @Post('/') async create(@Body() data: CreatePostDto) { if (!data.title || data.title.length < 3) { throw HttpException.badRequest('Title must be at least 3 characters'); } const existingPost = await this.findByTitle(data.title); if (existingPost) { throw HttpException.conflict('Post with this title already exists'); } return await this.createPost(data); } } import { HttpException } from '@nl-framework/http'; // 400 Bad Request throw HttpException.badRequest('Invalid input'); // 401 Unauthorized throw HttpException.unauthorized('Authentication required'); // 403 Forbidden throw HttpException.forbidden('Access denied'); // 404 Not Found throw HttpException.notFound('Resource not found'); // 409 Conflict throw HttpException.conflict('Resource already exists'); // 422 Unprocessable Entity throw HttpException.unprocessableEntity('Validation failed'); // 500 Internal Server Error throw HttpException.internalServerError('Something went wrong'); // 503 Service Unavailable throw HttpException.serviceUnavailable('Service temporarily unavailable'); // Custom status code throw new HttpException(418, \"I'm a teapot\"); import { ExceptionFilter } from '@nl-framework/http'; import { ValidationException } from '@nl-framework/core'; import type { RequestContext } from '@nl-framework/http'; export class ValidationExceptionFilter implements ExceptionFilter { async catch(exception: Error, context: RequestContext): Promise<Response> { if (exception instanceof ValidationException) { return new Response( JSON.stringify({ statusCode: 400, message: 'Validation failed', errors: exception.issues.map((issue) => ({ field: issue.path.join('.'), message: issue.message, })), }), { status: 400, headers: { 'Content-Type': 'application/json' }, } ); } // Let other filters handle this throw exception; } } import { ExceptionFilter, HttpException } from '@nl-framework/http'; import type { RequestContext } from '@nl-framework/http'; export class ProblemJsonFilter implements ExceptionFilter { async catch(exception: Error, context: RequestContext): Promise<Response> { const url = new URL(context.request.url); if (exception instanceof HttpException) { return new Response( JSON.stringify({ type: \\`/errors/\\${exception.status}\\`, title: this.getStatusText(exception.status), status: exception.status, detail: exception.message, instance: url.pathname, }), { status: exception.status, headers: { 'Content-Type': 'application/problem+json' }, } ); } return new Response( JSON.stringify({ type: '/errors/500', title: 'Internal Server Error', status: 500, detail: exception.message, instance: url.pathname, }), { status: 500, headers: { 'Content-Type': 'application/problem+json' }, } ); } private getStatusText(status: number): string { const statusTexts: Record<number, string> = { 400: 'Bad Request', 401: 'Unauthorized', 403: 'Forbidden', 404: 'Not Found', 409: 'Conflict', 422: 'Unprocessable Entity', 500: 'Internal Server Error', 503: 'Service Unavailable', }; return statusTexts[status] || 'Error'; } } import { ExceptionFilter, HttpException } from '@nl-framework/http'; import { Logger, LoggerFactory } from '@nl-framework/logger'; import type { RequestContext } from '@nl-framework/http'; export class LoggingExceptionFilter implements ExceptionFilter { private readonly logger: Logger; constructor(loggerFactory: LoggerFactory) { this.logger = loggerFactory.create({ context: 'ExceptionFilter' }); } async catch(exception: Error, context: RequestContext): Promise<Response> { const url = new URL(context.request.url); const status = exception instanceof HttpException ? exception.status : 500; this.logger.error('Request exception', exception, { method: context.request"
  },
  {
    "title": "CLI Reference · Nael Platform",
    "description": "Full reference for the nl CLI including generators, diagnostics, and workspace scripts.",
    "href": "/docs/cli",
    "section": "cli",
    "headings": [],
    "content": "bun install --global @nl-framework/cli`; export const newService = `nl new shipping-service --template=graphql --features=auth,redis nl generate module billing --public`; export const runDoctor = `nl doctor --checks env,versions --fix nl dev          # starts Bun dev server\\nnl start        # production boot\\nnl build        # emits dist/ for all packages`; export const commandMatrix = [ { name: 'nl new', description: 'Scaffold a new service with HTTP, GraphQL, Better Auth, or worker templates.', flags: '--template --features --package-manager --install', }, { name: 'nl generate', description: 'Add modules, controllers, resolvers, providers, schedulers, or Dapr subscribers.', flags: 'module|controller|resolver|provider|subscriber|cron', }, { name: 'nl sync', description: 'Sync versions across packages, apply lint rules, and re-run project references.', flags: '--workspace --dry-run', }, { name: 'nl doctor', description: 'Run environment diagnostics (Bun version, Dapr, BetterAuth secrets, Docker).', flags: '--checks --fix', }, ]; <div className=\"space-y-10\"> <div className=\"space-y-3\"> <div className=\"text-sm uppercase tracking-wide text-muted-foreground\">Reference</div> <h1 className=\"text-4xl font-semibold\">`nl` CLI</h1> <div className=\"max-w-2xl text-muted-foreground\"> The CLI wraps Bun scripts, code generators, and project diagnostics so you can stay focused on features. Every command mirrors NestJS naming while embracing Bun-native performance. </div> </div> <section className=\"space-y-6\"> <Card className=\"border-border/80\"> <CardHeader> <CardTitle>Install once</CardTitle> <CardDescription>Available through Bun, npm, or pnpm.</CardDescription> </CardHeader> <CardContent className=\"space-y-3\"> <CodeBlock code={installCli} title=\"Global install\" /> <div className=\"text-sm text-muted-foreground\"> Prefer local devDependency? Run `bun add -D @nl-framework/cli` inside your repo and call via ` bun x nl ...`. </div> </CardContent> </Card> <Card className=\"border-border/80\"> <CardHeader> <CardTitle>Scaffold services</CardTitle> <CardDescription>Choose templates + opt-in features.</CardDescription> </CardHeader> <CardContent className=\"space-y-3\"> <CodeBlock code={newService} title=\"GraphQL template\" /> <div className=\"text-sm text-muted-foreground\"> Templates ship with sensible defaults: configuration module, structured logger, health checks, and pluggable transports. Flags control stack pieces (Redis, queues, federation gateway, Dapr sidecars). </div> </CardContent> </Card> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Generate artifacts</h2> <div className=\"text-muted-foreground\"> Generators respect the current working directory and automatically register the new class inside the parent module. Use `--public` to export from the index barrel. </div> <CodeBlock code={generateModule} title=\"Public billing module\" /> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Everyday scripts</h2> <div className=\"text-muted-foreground\"> `nl` proxies core Bun scripts so CI stays simple. Call `nl dev` to boot the active service with watch mode, or add `--cwd` to run from any example folder. </div> <CodeBlock code={runScripts} title=\"Script shorthands\" /> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Command matrix</h2> <div className=\"grid gap-4 md:grid-cols-2\"> {commandMatrix.map((command) => ( <Card className=\"border-border/70\" key={command.name}> <CardHeader> <CardTitle>{command.name}</CardTitle> <CardDescription>{command.flags}</CardDescription> </CardHeader> <CardContent> <div className=\"text-sm text-muted-foreground\">{command.description}</div> </CardContent> </Card> ))} </div> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Diagnostics</h2> <div className=\"text-muted-foreground\"> `nl doctor` inspects Bun versions, ensures Postgres is reachable, validates Dapr sidecars, and confirms Better Auth secrets exist before deployment. Pass `--fix` to auto-create missing files. </div> <CodeBlock code={runDoctor} title=\"Force checks\" /> <div className=\"text-sm text-muted-foreground\"> Need more? Wire your own health checks and register them via `DoctorRegistry.register()` inside your service bootstrap. </div> </section> <section className=\"space-y-3\"> <h2 className=\"text-2xl font-semibold\">Where to go next</h2> <div className=\"text-muted-foreground\"> Review the <Link className=\"text-primary\" href=\"/docs/installation\">installation matrix</Link> or learn how we build Better Auth experiences in the <Link className=\"text-primary\" href=\"/docs/techniques/better-auth\">techniques guide</Link>. </div> </section> </div> The CLI wraps Bun scripts, code generators, and project diagnostics so you can stay focused on features. Every command mirrors NestJS naming while embracing Bun-native performance. Prefer local devDependency? Run bun add -D @nl-framework/cli inside your repo and call via bun x nl .... Temp"
  },
  {
    "title": "Pipes · Nael Platform",
    "description": "Learn how to use pipes for transforming and validating input data before it reaches route handlers in Nael applications.",
    "href": "/docs/pipes",
    "section": "pipes",
    "headings": [],
    "content": "import { PipeTransform, ArgumentMetadata } from '@nl-framework/http'; export class TrimPipe implements PipeTransform<string, string> { transform(value: string, metadata: ArgumentMetadata): string { return typeof value === 'string' ? value.trim() : value; } } import { Controller, Get, Query, UsePipes } from '@nl-framework/http'; @Controller('/search') export class SearchController { @Get('/') search(@Query('q', TrimPipe) query: string) { return { query }; } } import { Controller, Get, Param, ParseIntPipe } from '@nl-framework/http'; @Controller('/users') export class UsersController { @Get('/:id') findOne(@Param('id', ParseIntPipe) id: number) { // id is automatically converted to a number return { id, type: typeof id }; // { id: 123, type: 'number' } } } import { ParseIntPipe, ParseFloatPipe, ParseBoolPipe, ParseArrayPipe, DefaultValuePipe, } from '@nl-framework/http'; @Controller('/products') export class ProductsController { @Get('/') list( @Query('page', ParseIntPipe) page: number, @Query('limit', ParseIntPipe) limit: number, @Query('active', ParseBoolPipe) active: boolean, @Query('tags', new ParseArrayPipe({ separator: ',' })) tags: string[], @Query('sort', new DefaultValuePipe('name')) sort: string, ) { return { page, limit, active, tags, sort }; } } import { Controller, Post, Body, ValidationPipe } from '@nl-framework/http'; import { IsEmail, IsString, MinLength } from 'class-validator'; class CreateUserDto { @IsEmail() email!: string; @IsString() @MinLength(3) name!: string; } @Controller('/users') export class UsersController { @Post('/') create(@Body(ValidationPipe) data: CreateUserDto) { // data is validated and transformed return { message: 'User created', data }; } } import { Controller, Post, Body, UsePipes, ValidationPipe } from '@nl-framework/http'; @Controller('/users') @UsePipes(new ValidationPipe({ transform: true, whitelist: true })) export class UsersController { @Post('/') create(@Body() data: CreateUserDto) { // ValidationPipe is applied to all parameters return { message: 'User created', data }; } @Post('/bulk') createMany(@Body() data: CreateUserDto[]) { // ValidationPipe is applied here too return { message: 'Users created', count: data.length }; } } import { Controller, Post, UsePipes, ValidationPipe } from '@nl-framework/http'; @Controller('/products') export class ProductsController { @Post('/') @UsePipes(new ValidationPipe({ whitelist: true, forbidNonWhitelisted: true })) create(@Body() data: CreateProductDto) { return { message: 'Product created', data }; } @Post('/import') @UsePipes(new ValidationPipe({ skipMissingProperties: true })) import(@Body() data: ImportProductDto[]) { return { message: 'Products imported', count: data.length }; } } import { PipeTransform, ArgumentMetadata, HttpException } from '@nl-framework/http'; export class FileSizeValidationPipe implements PipeTransform { constructor(private readonly maxSize: number) {} transform(value: any, metadata: ArgumentMetadata): any { if (value?.size && value.size > this.maxSize) { throw HttpException.badRequest( \\`File size exceeds maximum of \\${this.maxSize} bytes\\` ); } return value; } } @Controller('/upload') export class UploadController { @Post('/') upload(@Body(new FileSizeValidationPipe(1024 \\* 1024)) file: any) { return { message: 'File uploaded', size: file.size }; } } import { PipeTransform, ArgumentMetadata } from '@nl-framework/http'; export class UpperCasePipe implements PipeTransform<string, string> { transform(value: string, metadata: ArgumentMetadata): string { return value?.toUpperCase() || value; } } export class SlugifyPipe implements PipeTransform<string, string> { transform(value: string, metadata: ArgumentMetadata): string { return value .toLowerCase() .trim() .replace(/[^\\\\w\\\\s-]/g, '') .replace(/[\\\\s_-]+/g, '-') .replace(/^-+|-+$/g, ''); } } @Controller('/posts') export class PostsController { @Post('/') create( @Body('title', SlugifyPipe) slug: string, @Body('name', UpperCasePipe) name: string, ) { return { slug, name }; } } import { PipeTransform, ArgumentMetadata, HttpException } from '@nl-framework/http'; export class UserExistsPipe implements PipeTransform { async transform(userId: string, metadata: ArgumentMetadata): Promise<string> { const user = await this.findUser(userId); if (!user) { throw HttpException.notFound(\\`User with ID \\${userId} not found\\`); } return userId; } private async findUser(id: string) { // Query database return null; } } @Controller('/posts') export class PostsController { @Post('/') create( @Body('userId', UserExistsPipe) userId: string, @Body('title') title: string, ) { return { userId, title }; } } import { Controller, Get, Query, ParseArrayPipe, ParseIntPipe } from '@nl-framework/http'; @Controller('/products') export class ProductsController { @Get('/filter') filter( // Parse comma-separated string into array @Query('tags', new ParseArrayPipe({ separator: ',' })) tags: string[], // Parse comma-separated numbers @Query( 'ids', new ParseArrayPipe({ separator: ',',"
  },
  {
    "title": "First Steps · Nael Platform",
    "description": "Learn how to create your first Nael Platform application with Bun runtime.",
    "href": "/docs/first-steps",
    "section": "first-steps",
    "headings": [],
    "content": "bun install --global @nl-framework/cli`; export const createProject = `nl new my-app import { NaelFactory } from '@nl-framework/core'; async function bootstrap() { const app = await NaelFactory.create(AppModule); await app.listen(3000); console.log(\\`Application is running on: http://localhost:3000\\`); } bootstrap(); import { Module } from '@nl-framework/core'; @Module({ imports: [], controllers: [AppController], providers: [AppService], }) export class AppModule {} import { Controller, Get } from '@nl-framework/http'; @Controller() export class AppController { constructor(private readonly appService: AppService) {} @Get() getHello(): string { return this.appService.getHello(); } } import { Injectable } from '@nl-framework/core'; @Injectable() export class AppService { getHello(): string { return 'Hello Nael Platform!'; } } bun run dev`; <div className=\"space-y-10\"> <div className=\"space-y-3\"> <div className=\"text-sm uppercase tracking-wide text-muted-foreground\">Overview</div> <h1 className=\"text-4xl font-semibold\">First steps</h1> <div className=\"max-w-2xl text-muted-foreground\"> In this guide, you&apos;ll learn the core fundamentals of Nael Platform. To get familiar with the essential building blocks of the framework, we&apos;ll build a basic HTTP application with features that cover a lot of ground at an introductory level. </div> </div> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Language</h2> <div className=\"text-muted-foreground\"> Nael Platform is built entirely for <Link className=\"text-primary\" href=\"https://bun.sh\" rel=\"noreferrer\" target=\"_blank\">Bun</Link>, a fast all-in-one JavaScript runtime. We use TypeScript and leverage modern ES modules. While the framework is compatible with vanilla JavaScript, we strongly recommend using TypeScript for the best development experience. </div> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Prerequisites</h2> <div className=\"text-muted-foreground\"> Please make sure that <Link className=\"text-primary\" href=\"https://bun.sh/docs/installation\" rel=\"noreferrer\" target=\"_blank\">Bun</Link> (version &gt;= 1.1.0) is installed on your operating system. </div> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Setup</h2> <div className=\"text-muted-foreground\"> Setting up a new project is quite simple with the Nael CLI. With Bun installed, you can create a new project with the following commands: </div> <CodeBlock code={installCli} title=\"Install CLI globally\" /> <CodeBlock code={createProject} title=\"Create new project\" /> <div className=\"text-sm text-muted-foreground\"> The `my-app` directory will be created, modules will be installed, and several boilerplate files will be created and populated. Here&apos;s a brief overview of the core files: </div> <ul className=\"list-disc space-y-2 pl-5 text-sm text-muted-foreground\"> <li><code>src/main.ts</code> - The entry file of the application which uses the core function <code>NaelFactory</code> to create an application instance.</li> <li><code>src/app.module.ts</code> - The root module of the application.</li> <li><code>src/app.controller.ts</code> - A basic controller with a single route.</li> <li><code>src/app.service.ts</code> - A basic service with a single method.</li> <li><code>config/default.yaml</code> - Configuration file for different environments.</li> </ul> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Main file</h2> <div className=\"text-muted-foreground\"> The `main.ts` includes an async function which will bootstrap our application: </div> <CodeBlock code={mainFile} title=\"src/main.ts\" /> <div className=\"text-sm text-muted-foreground\"> To create a Nael application instance, we use the core `NaelFactory` class. `NaelFactory` exposes a few static methods that allow creating an application instance. The `create()` method returns an application object, which implements the `INaelApplication` interface. </div> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Application module</h2> <div className=\"text-muted-foreground\"> The application module (`AppModule`) is the root module of your application. Nael uses a module structure to organize components. </div> <CodeBlock code={appModule} title=\"src/app.module.ts\" /> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Controller</h2> <div className=\"text-muted-foreground\"> Controllers are responsible for handling incoming requests and returning responses to the client. </div> <CodeBlock code={appController} title=\"src/app.controller.ts\" /> <div className=\"text-sm text-muted-foreground\"> The `@Controller()` decorator is required to define a basic controller. The `@Get()` HTTP request method decorator tells Nael to create a handler for a specific endpoint for HTTP requests. </div> </section> <section className=\"space-y-4\"> <h2 className=\"text-2xl font-semibold\">Provider</h2> <div classNa"
  },
  {
    "title": "Getting Started · Nael Platform",
    "description": "Scaffold and run Nael Platform services with the CLI or the monorepo examples.",
    "href": "/docs/getting-started",
    "section": "getting-started",
    "headings": [],
    "content": "bun install --global @nl-framework/cli`; export const bootstrapService = `nl new fleet-service cd fleet-service bun install bun run dev bun install bun run build bun run --cwd examples/auth-multi-tenant-http start Install the CLI, scaffold a Bun-native service, and explore the curated examples. The CLI mirrors NestJS ergonomics while running entirely on Bun for faster startup times. The nl binary ships generators for new services, modules, controllers, resolvers, and background workers. Choose HTTP, GraphQL, Better Auth, or microservice blueprints. The CLI always boots a NaelFactory instance wired with logging and configuration. Every capability in the README maps to an example inside examples/. Build once at the root, then point the --cwd flag to the folder you want to explore. The auth-multi-tenant- examples demonstrate how to hydrate per-tenant configuration, reuse HTTP auth routes, and expose Better Auth via GraphQL. Key steps: Register tenant metadata inside config/tenants.yaml and expose typed config tokens. Use BetterAuthMultiTenantGuard to bind sessions to the active tenant. Forward the Better Auth HTTP router via BetterAuthProxyModule so SPA clients stay in sync. Need a federation-friendly flavor? Switch to examples/auth-multi-tenant-graphql and follow the README inside that folder. Unified HTTP + GraphQL + Gateway wiring with shared dependency injection context. YAML-backed config module and structured logging with child logger support. Shared session middleware across HTTP and GraphQL plus helpers for proxying the Better Auth routes. nl g module users, nl g controller auth, nl g resolver profile mirror NestJS-style ergonomics. Head to the Installation guide for per-package instructions or open any folder under examples/ for focused walkthroughs."
  },
  {
    "title": "GraphQL Exception Handling - NL Framework",
    "description": "Learn how to handle exceptions in GraphQL resolvers using NL Framework",
    "href": "/docs/graphql/exception-handling",
    "section": "graphql",
    "headings": [],
    "content": "import { ApplicationException } from '@nl-framework/graphql'; import { Resolver, Query, Mutation, Arg } from '@nl-framework/graphql'; @Resolver() export class UserResolver { @Query(() => User) async getUser(@Arg('id') id: string): Promise<User> { const user = await this.userRepository.findById(id); if (!user) { throw ApplicationException.notFound('User not found'); } return user; } @Mutation(() => User) async createUser(@Arg('input') input: CreateUserInput): Promise<User> { const existing = await this.userRepository.findByEmail(input.email); if (existing) { throw ApplicationException.conflict( 'User already exists', { email: input.email } ); } return this.userRepository.create(input); } } import { GraphQLExceptionFilter } from '@nl-framework/graphql'; import { GraphQLError } from 'graphql'; import { ApplicationException } from '@nl-framework/core'; export class CustomGraphQLExceptionFilter implements GraphQLExceptionFilter { async catch(exception: Error): Promise<GraphQLError | null> { if (exception instanceof ApplicationException) { return new GraphQLError(exception.message, { extensions: { code: exception.code, details: exception.details, timestamp: new Date().toISOString(), service: 'user-service', }, }); } return null; } } import { createGraphqlApplication, registerGraphQLExceptionFilter } from '@nl-framework/graphql'; async function bootstrap() { const app = await createGraphqlApplication({ modules: [AppModule], }); registerGraphQLExceptionFilter(new CustomGraphQLExceptionFilter()); await app.start(); } { \"data\": null, \"errors\": [ { \"message\": \"User not found\", \"locations\": [{ \"line\": 2, \"column\": 3 }], \"path\": [\"getUser\"], \"extensions\": { \"code\": \"NOT_FOUND\", \"details\": { \"userId\": \"123\" } } } ] } @Resolver() export class PostResolver { @Query(() => [Post]) async myPosts(@Context('user') user: User): Promise<Post[]> { if (!user) { throw ApplicationException.unauthorized('You must be logged in'); } return this.postRepository.findByAuthor(user.id); } } @Resolver() export class PostResolver { @Mutation(() => Post) async createPost(@Arg('input') input: CreatePostInput): Promise<Post> { if (input.title.length < 3) { throw ApplicationException.validationError( 'Title must be at least 3 characters', { field: 'title', min: 3 } ); } return this.postRepository.create(input); } } export class DetailedGraphQLExceptionFilter implements GraphQLExceptionFilter { async catch(exception: Error): Promise<GraphQLError | null> { if (exception.message.includes('unique constraint')) { return new GraphQLError('Duplicate entry', { extensions: { code: 'DUPLICATE_ENTRY', originalError: exception.message, }, }); } if (exception instanceof ApplicationException) { return new GraphQLError(exception.message, { extensions: { code: exception.code, details: exception.details, cause: exception.cause?.message, }, }); } if (process.env.NODE_ENV === 'production') { return new GraphQLError('An error occurred', { extensions: { code: 'INTERNAL_SERVER_ERROR' }, }); } return null; } } Exception handling in GraphQL allows you to catch and format errors from resolvers, providing consistent error responses to clients. NL Framework provides exception filters that integrate seamlessly with GraphQL error formatting. 💡 Transport-Agnostic: ApplicationException from @nl-framework/core works across HTTP, GraphQL, and any other transport layer. Use the same exception class everywhere! The ApplicationException class is transport-agnostic and automatically converts to appropriate GraphQL error codes: ApplicationException error codes are automatically mapped to GraphQL error codes: Exception filters allow you to customize how exceptions are converted to GraphQL errors: GraphQL errors are returned in the standard GraphQL error format: ✅ Summary: GraphQL exception handling in NL Framework uses ApplicationException for transport-agnostic errors with automatic conversion to standard GraphQL error codes. Exception filters enable custom error formatting, and the system provides consistent error handling across HTTP and GraphQL."
  },
  {
    "title": "Overview · Nael Platform",
    "description": "Learn about Nael Platform philosophy, installation options, Better Auth integration, GraphQL, and microservices support.",
    "href": "/docs",
    "section": "Docs",
    "headings": [],
    "content": "bun install --global @nl-framework/cli nl new platform-demo cd platform-demo bun run dev git clone https://github.com/Nael-Studio/nael-platform.git cd nael-platform bun install bun run build git clone https://github.com/Nael-Studio/nael-platform.git --depth=1 --single-branch cd nael-platform bun run --cwd examples/basic-http start import { BetterAuthModule } from '@nl-framework/auth'; @Module({ imports: [ BetterAuthModule.register({ baseUrl: env.BETTER_AUTH_URL, multiTenant: true, }), ], }) export class AuthModule {} GraphqlModule.forRoot({ schemaPath: './src/schema.graphql', federation: true, playground: true, }); createMicroservicesModule({ controllers: [BillingController], dapr: { pubsubName: 'redis-pubsub', }, }); A NestJS-inspired framework that runs entirely on Bun. Combine Better Auth, Apollo Federation, Dapr microservices, and schedulers without juggling multiple ecosystems. This page mirrors nestjs.com depth so you can ship production-ready services quickly. Decorator-driven modules, Bun-native HTTP and GraphQL servers, shared DI contexts, and full Better Auth integration (single-tenant and multi-tenant) with zero CommonJS shims. Weekly alpha releases keep the framework aligned with Bun updates and Better Auth changes. Subscribe to the changelog in the right rail or star the repo to follow along. Inspired by NestJS but optimized for Bun, Nael keeps the &ldquo;lego-brick&rdquo; approach to modules while shedding layered build steps. Everything is native ESM, meaning faster cold starts, effortless workers, and aligned tooling. Unified HTTP, GraphQL, federation gateway, and microservices factories via NaelFactory. Better Auth-first mindset: guards, middleware, tenant-aware resolvers, and HTTP proxies included. Choose the workflow that matches your team. The CLI scaffolds clean services, while the monorepo unlocks every example and package. Generates HTTP + GraphQL boilerplate, registers Better Auth, and wires config/logging. Run nl g module billing or nl g resolver user as you grow the surface area. Ideal for contributing or exploring every package. Each example has its own start script and shares dependencies via Bun workspaces. Great for CI examples or one-off demos. Run dapr init and start the microservices example without keeping git history around. Shared guards, middleware, and HTTP proxies mean REST + GraphQL stay in sync. Enable tenant-aware sessions with a single config block. Schema-first development with Apollo Server under the hood. Run a gateway and subgraphs from the same NaelFactory instance or deploy them independently. Each resolver module can opt-in to federation without toggling feature flags. Subgraphs share the logging + config stack automatically. Decorators such as @UseInterceptors() now wrap GraphQL resolvers, allowing shared caching/logging envelopes across transports. Register global resolver middleware with registerGraphqlInterceptor() to apply observability or auth layers everywhere. Dapr pub/sub transports, Bun Worker schedulers, and message pattern decorators mirror the NestJS API you already know. <Link href=\"https://github.com/Nael-Studio/nael-platform/tree/main/examples\" rel=\"noreferrer\" target=\"blank\" Browse repo Nael is MIT + Apache 2.0 and depends on sponsors. If the framework powers your platform, consider funding maintenance and roadmap items. Trilon, Mach10, and the Nael Studio collective keep CI running and ensure Better Auth parity. Your company can join them. Become a sponsor"
  },
  {
    "title": "ORM multi-tenancy · Nael Platform",
    "description": "Model one connection per region, tenant tier, or customer and resolve repositories dynamically.",
    "href": "/docs/orm/multi-tenancy",
    "section": "orm",
    "headings": [],
    "content": "import { Module } from '@nl-framework/core'; import { OrmModule, createMongoDriver } from '@nl-framework/orm'; @Module({ imports: [ OrmModule.forRoot({ connectionName: 'tenant-us', driver: createMongoDriver({ uri: process.env.MONGO_URI_US!, dbName: 'tenant_us' }), }), OrmModule.forRoot({ connectionName: 'tenant-eu', driver: createMongoDriver({ uri: process.env.MONGO_URI_EU!, dbName: 'tenant_eu' }), }), OrmModule.forFeature({ connectionName: 'tenant-us', entities: [Invoice] }), OrmModule.forFeature({ connectionName: 'tenant-eu', entities: [Invoice] }), ], }) export class TenantOrmModule {} import { Inject, Injectable, ModuleRef, Scope } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; interface TenantContext { connection: 'tenant-us' | 'tenant-eu'; tenantId: string; } @Injectable({ scope: Scope.REQUEST }) export class TenantInvoicesService { constructor( private readonly tenant: TenantContext, private readonly moduleRef: ModuleRef, ) {} async listInvoices() { const token = getRepositoryToken(Invoice, this.tenant.connection); const repository = (await this.moduleRef.resolve(token, { strict: false })) as OrmRepository<Invoice>; return repository.find({ tenantId: this.tenant.tenantId }); } } const connectionName = tenant.region === 'eu' ? 'tenant-eu' : 'tenant-us'; return { connectionName, driver: createMongoDriver({ uri: secrets.getUriFor(tenant), dbName: secrets.getDbNameFor(tenant), }), }; Some apps dedicate a database per region or customer. The ORM lets you register multiple connections in the same process and route requests to the right repository without keeping global singletons. Call OrmModule.forRoot() for each tenant slice. Give every connection a descriptive name so repositories, seeds, and tokens stay unambiguous. Feature modules then import OrmModule.forFeature() per connection to expose the right repositories. Combine execution-context data (tenant IDs, regions) with ModuleRef to pick the correct repository on demand. Because repository tokens include the connection name, the DI container keeps each tenant isolated while still running inside the same app instance. Pair forRootAsync() with BetterAuth or your own tenant registry to fetch secrets per tenant. The factory can compute the connection name and driver settings on the fly, returning a unique URI per tenant. Use the connections option on @Seed so only relevant seeds run for each connection. Seed history is scoped to both the connection name and environment, so regional databases stay in sync without extra bookkeeping."
  },
  {
    "title": "ORM complex queries · Nael Platform",
    "description": "Pattern matching, aggregation pipelines, and advanced Mongo operators using the Nael ORM.",
    "href": "/docs/orm/queries",
    "section": "orm",
    "headings": [],
    "content": "import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class DirectoryService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async search(term: string) { const pattern = new RegExp(term.replace(/[-/\\\\^$\\*+?.()|[\\]{}]/g, '.'), 'i'); return this.users.find({ $or: [{ email: { $regex: pattern } }, { name: { $regex: pattern } }], }); } } await this.users.find( { email: { $regex: /^ops\\./, $options: 'i' }, plan: { $in: ['pro', 'enterprise'] } }, { projection: { email: 1, name: 1, plan: 1 }, sort: { createdAt: -1 }, limit: 50, }, ); import { Inject, Injectable } from '@nl-framework/core'; import { getDatabaseToken } from '@nl-framework/orm'; import type { Db } from 'mongodb'; @Injectable() export class RevenueService { constructor(@Inject(getDatabaseToken('billing')) private readonly db: Db) {} async monthlyTotals() { return this.db.collection('invoices').aggregate([ { $match: { paidAt: { $exists: true } } }, { $group: { _id: { $dateTrunc: { date: '$paidAt', unit: 'month' } }, total: { $sum: '$amount' }, }, }, { $sort: { _id: 1 } }, ]).toArray(); } } import { Inject, Injectable } from '@nl-framework/core'; import { getConnectionToken, getRepositoryToken, type OrmConnection, type OrmRepository } from '@nl-framework/orm'; import type { Collection } from 'mongodb'; @Injectable() export class AgingService { private collection: Collection<Invoice>; constructor( @Inject(getConnectionToken()) private readonly connection: OrmConnection, @Inject(getRepositoryToken(Invoice)) private readonly invoices: OrmRepository<Invoice>, ) {} async agingBuckets() { if (!this.collection) { this.collection = await this.connection.getCollection(Invoice); } return this.collection.aggregate([ { $match: { status: 'unpaid' } }, { $project: { customerId: 1, daysOutstanding: { $dateDiff: { startDate: '$issuedAt', endDate: '$$NOW', unit: 'day' }, }, }, }, { $bucket: { groupBy: '$daysOutstanding', boundaries: [0, 30, 60, 90, 120], default: '120+', output: { count: { $sum: 1 } }, }, }, ]).toArray(); } } // Request-scoped service keeping tenant context await this.moduleRef.resolve(getRepositoryToken(User, tenantConnection), { strict: false }); // Prefer projection for large documents await this.users.find({ plan: 'enterprise' }, { projection: { email: 1, name: 1 } }); // Combine soft-delete filters manually when reading archives await this.users.find({ deletedAt: { $ne: null } }, { withDeleted: true }); The ORM gives you ergonomic repositories for common CRUD, but you can still tap into Mongo's richer query operators—regex, buckets, pipelines, and computed projections—without abandoning the DI-friendly APIs. Mongo does not support SQL's LIKE, but $regex covers the same ground. Construct the pattern once, escape user input, and pass it directly through find(). You can still combine it with other filters or projections. For analytics, buckets, or computed metrics, resolve the underlying Mongo Db via getConnectionToken() and call collection.aggregate(). Pipelines run inside the same connection pool and share configuration with the rest of your app. If you prefer to start from an existing repository, you can reach for the underlying collection instance. Keep this in a dedicated service and document the escape hatch so teammates know when aggregation logic bypasses the higher-level repository helpers. Advanced queries can still play nicely with scopes and tenancy. Keep these guardrails in mind:"
  },
  {
    "title": "ORM seeding · Nael Platform",
    "description": "Register seeds, track execution history, and run them automatically or on demand.",
    "href": "/docs/orm/seeding",
    "section": "orm",
    "headings": [],
    "content": "import { Seed, type SeederContext } from '@nl-framework/orm'; @Seed({ name: 'initial-users', environments: ['development', 'test'] }) export class InitialUsersSeed { async run(context: SeederContext) { const users = await context.getRepository(User); const existing = await users.count(); if (existing > 0) { return; } await users.insertMany([ { email: 'admin@example.com', name: 'Admin' }, { email: 'dev@example.com', name: 'Developer' }, ]); } } import { Inject, Injectable, OnModuleInit } from '@nl-framework/core'; import { getSeedRunnerToken, type SeedRunner } from '@nl-framework/orm'; @Injectable() export class ManualSeeder implements OnModuleInit { constructor( @Inject(getSeedRunnerToken('analytics')) private readonly runner: SeedRunner, ) {} async onModuleInit() { await this.runner.run(); } } OrmModule.forRoot({ driver: createMongoDriver({ uri: process.env.MONGO_URI!, dbName: 'app-db' }), autoRunSeeds: process.env.AUTO_RUN_SEEDS !== 'false', seedEnvironment: process.env.APP_ENV ?? process.env.NODE_ENV ?? 'default', }); Seeds let you populate fixtures, lookup data, or idempotent migrations whenever a connection boots. Nael tracks which seeds have executed per environment and per connection, so restarting your app never results in duplicate documents. Use the @Seed decorator on a class with a run() method. The decorator accepts an optional name, target connections, and the environments it should run in. Inside run, you can ask the context for any repository registered with the same connection. When autoRunSeeds is enabled, the ORM executes seeds as part of module initialization. Each run is recorded in the driver-provided history store (Mongo keeps this in ormseedhistory), keyed by seed ID, connection name, and environment. Use seedEnvironment to align with deployment stages. The value is compared case-insensitively against the list declared in @Seed. Prefer explicit control? Inject SeedRunner via getSeedRunnerToken(connectionName) and call run() yourself—perfect for CLI commands or admin endpoints."
  },
  {
    "title": "ORM repositories · Nael Platform",
    "description": "Inject repositories, scope them per request, and use helper methods for query, persistence, and soft-delete flows.",
    "href": "/docs/orm/repositories",
    "section": "orm",
    "headings": [],
    "content": "import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class UsersService { constructor( @Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>, ) {} list() { return this.users.find(); } } import { Inject, Injectable, Scope } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable({ scope: Scope.REQUEST }) export class TenantInvoicesService { constructor( private readonly tenantId: string, @Inject(getRepositoryToken(Invoice)) private readonly invoices: OrmRepository<Invoice>, ) {} findForTenant() { return this.invoices.find({ tenantId: this.tenantId }); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class MetadataService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} collection() { return this.users.collectionName; } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class MetadataService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} entityCtor() { return this.users.entity.name; } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class AdminsService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} listPremium() { return this.users.find( { plan: 'pro' }, { sort: { createdAt: -1 }, limit: 20, projection: { email: 1, name: 1 } }, ); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class UsersLookupService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async byEmail(email: string) { return this.users.findOne({ email }, { withDeleted: true }); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class ProfilesService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async getProfile(id: string) { return this.users.findById(id); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class StatsService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async countAdmins() { return this.users.count({ role: 'admin' }); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class RegistrationService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async register(email: string, name: string) { return this.users.insertOne({ email, name, plan: 'free' }); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class SeedService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} bulkInsert(batch: Array<Pick<User, 'email' | 'name'>>) { return this.users.insertMany(batch); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class ProfilesService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async upsertProfile(id: string, name: string) { return this.users.save({ id, name }); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class BillingService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async downgradeTrials() { return this.users.updateMany({ trialEnded: true }, { plan: 'free' }); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class ArchiveService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async archive(id: string) { return this.users.softDelete({ id }); } } import { Inject, Injectable } from '@nl-framework/core'; import { getRepositoryToken, type OrmRepository } from '@nl-framework/orm'; @Injectable() export class ArchiveService { constructor(@Inject(getRepositoryToken(User)) private readonly users: OrmRepository<User>) {} async restore(id: string) { return this.users.restore"
  },
  {
    "title": "Nael ORM overview · Nael Platform",
    "description": "Install and register the Nael ORM, connect drivers, and expose connection tokens across your application.",
    "href": "/docs/orm/overview",
    "section": "orm",
    "headings": [],
    "content": "import { Module } from '@nl-framework/core'; import { OrmModule, createMongoDriver } from '@nl-framework/orm'; @Module({ imports: [ OrmModule.forRoot({ driver: createMongoDriver({ uri: process.env.MONGO_URI!, dbName: 'app-db', }), connectionName: 'primary', autoRunSeeds: true, seedEnvironment: process.env.APP_ENV ?? process.env.NODE_ENV ?? 'default', }), ], }) export class AppModule {} import { Module } from '@nl-framework/core'; import { ConfigModule, ConfigService } from '@nl-framework/config'; import { OrmModule, createMongoDriver } from '@nl-framework/orm'; @Module({ imports: [ ConfigModule, OrmModule.forRootAsync({ imports: [ConfigModule], inject: [ConfigService], useFactory: (config: ConfigService) => ({ connectionName: config.get('database.connectionName', 'default'), driver: createMongoDriver({ uri: config.get('database.mongo.uri'), dbName: config.get('database.mongo.dbName'), }), autoRunSeeds: config.get('database.seeds.autoRun', false), seeds: [InitialUsersSeed], }), }), ], }) export class AppModule {} import { Inject, Injectable } from '@nl-framework/core'; import { getConnectionToken, getDatabaseToken, type OrmConnection } from '@nl-framework/orm'; import type { Db } from 'mongodb'; @Injectable() export class HealthService { constructor( @Inject(getConnectionToken()) private readonly connection: OrmConnection, @Inject(getDatabaseToken()) private readonly db: Db, ) {} async ping() { await this.connection.ensureConnection(); return this.db.command({ ping: 1 }); } } The ORM package aligns with Nael's DI container: connections are registered through modules, repositories become injectable providers, and seed runners plug into the lifecycle system. Start here if you need a persistent store without wiring raw drivers in every feature module. Call OrmModule.forRoot() once per database. Provide a driver—Mongo ships today and additional drivers can be added by exporting the OrmDriver interface. Each connection receives a name (defaults to default) so repositories, seeds, and tokens know which instance they should attach to. Auto-discovered entities and seeds are registered automatically as long as their files are imported before this module executes. Use forRootAsync() when URIs, credentials, or feature flags live in the configuration module , BetterAuth tenant resolvers, or secret stores. The factory can inject anything from the DI graph before returning the final driver settings. Beyond repositories, you can inject the raw connection or database handle for administrative work. Each helper accepts an optional connectionName so multi-database apps remain explicit. Continue to the other ORM guides to dive into documents, repositories, seeding, and multi-tenant setups."
  },
  {
    "title": "ORM documents · Nael Platform",
    "description": "Use the @Document decorator to describe collections, timestamps, and soft-delete behavior.",
    "href": "/docs/orm/entities",
    "section": "orm",
    "headings": [],
    "content": "import { Document } from '@nl-framework/orm'; @Document() export class User { id!: string; email!: string; name!: string; createdAt!: Date; updatedAt!: Date; deletedAt?: Date | null; } import { Document } from '@nl-framework/orm'; @Document({ collection: 'tenants', timestamps: true, softDelete: false }) export class Tenant { id!: string; slug!: string; plan!: 'free' | 'enterprise'; } import { Module } from '@nl-framework/core'; import { OrmModule, createMongoDriver } from '@nl-framework/orm'; @Module({ imports: [ OrmModule.forRoot({ driver: createMongoDriver({ uri: process.env.MONGO_URI!, dbName: 'app-db' }), entities: [User, Tenant], }), ], }) export class AppModule {} Entities in the Nael ORM are simple classes annotated with @Document(). Metadata drives collection names, timestamps, soft-delete, and auto-discovery so repositories know how to persist your models without extra boilerplate. Decorating a class registers it with the document registry. The default collection name is the kebab-case version of the class name (UserPreferences → user-preferences). Timestamps and soft-delete columns are enabled automatically, so repositories add createdAt, updatedAt, and deletedAt fields without additional code. The id property is always surfaced as a string even though MongoDB stores id internally. The repository keeps both in sync so your domain logic can work purely with string identifiers. Customize behavior with the decorator options: Any document that is imported before OrmModule.forRoot() runs is discovered automatically. Large apps sometimes prefer to pass an explicit entities array to scope a connection to a subset of documents. Even when you pass entities, decorators are still required so repositories know the collection metadata."
  },
  {
    "title": "Custom decorators · Nael Platform",
    "description": "Implement metadata and parameter decorators using SetMetadata, createHttpParamDecorator, and createGraphqlParamDecorator.",
    "href": "/docs/custom-decorators",
    "section": "custom-decorators",
    "headings": [],
    "content": "import { SetMetadata } from '@nl-framework/core'; import { Controller, Get, UseGuards } from '@nl-framework/http'; export const Roles = (...roles: string[]) => SetMetadata('roles', roles); @Controller('/admin') @Roles('admin') export class AdminController { @Get() @Roles('moderator') dashboard() { return { ok: true }; } } import 'reflect-metadata'; import { CanActivate } from '@nl-framework/core'; import { HttpExecutionContext } from '@nl-framework/http'; export class RolesGuard implements CanActivate { canActivate(context: HttpExecutionContext) { const handler = context.getHandler(); const controller = context.getClass(); const handlerRoles = Reflect.getMetadata('roles', handler) ?? []; const controllerRoles = Reflect.getMetadata('roles', controller) ?? []; if (!handlerRoles.length && !controllerRoles.length) { return true; } const request = context.getRequest(); const currentRole = request.headers.get('x-role'); const allowed = [...controllerRoles, ...handlerRoles]; return currentRole ? allowed.includes(currentRole) : false; } } import { Controller, Get, createHttpParamDecorator } from '@nl-framework/http'; export const CurrentUser = createHttpParamDecorator((property, ctx) => { const user = { id: ctx.headers.get('x-user-id'), role: ctx.headers.get('x-user-role'), }; if (!property) { return user; } return user[property]; }); @Controller('/profile') export class ProfileController { @Get() me(@CurrentUser('id') id: string, @CurrentUser() user: Record<string, unknown>) { return { id, user }; } } import { ObjectType, Field } from '@nl-framework/graphql'; import { Resolver, Query, createGraphqlParamDecorator } from '@nl-framework/graphql'; export const CurrentTenant = createGraphqlParamDecorator((property, ctx) => { const tenant = (ctx.context?.tenant ?? {}) as Record<string, unknown>; if (!property) { return tenant; } return tenant[property]; }); @ObjectType() class TenantInfo { @Field() id!: string; @Field() plan!: string; } @Resolver(() => TenantInfo) export class TenantResolver { @Query(() => TenantInfo) info(@CurrentTenant('plan') plan: string, @CurrentTenant('id') id: string) { return { id, plan }; } } Extend the framework with the same primitives NestJS documents—metadata decorators via SetMetadata and transport-aware parameter decorators with createHttpParamDecorator and createGraphqlParamDecorator. These helpers integrate with the router and schema builder so your decorators behave like first-party ones. Wrap class and handler definitions with domain-specific metadata. Under the hood SetMetadata stores values using reflect-metadata, allowing guards, interceptors, or any runtime component to look them up. Use createHttpParamDecorator() to capture values from RequestContext. Decorators participate in the same metadata pipeline as @Param() or @Body(), so pipes and validation keep working. GraphQL resolvers can define decorators with createGraphqlParamDecorator(). The factory receives the parent value, sanitized args, the shared context object, and GraphQLResolveInfo, mirroring NestJS&apos;s ExecutionContext."
  },
  {
    "title": "Modules · Nael Platform",
    "description": "Learn how to organize your Nael application using modules for better code structure and reusability.",
    "href": "/docs/modules",
    "section": "modules",
    "headings": [],
    "content": "// users/users.module.ts import { Module } from '@nl-framework/core'; @Module({ controllers: [UsersController], providers: [UsersService], }) export class UsersModule {} import { Module } from '@nl-framework/core'; @Module({ providers: [ConfigService], exports: [ConfigService], }) export class SharedModule {} import { Module } from '@nl-framework/core'; @Module({ imports: [ConfigModule, DatabaseModule], exports: [ConfigModule, DatabaseModule], }) export class CoreModule {} import { Module } from '@nl-framework/core'; @Module({ controllers: [UsersController], providers: [UsersService], }) export class UsersModule { constructor(private authService: AuthService) {} } import { Module, DynamicModule } from '@nl-framework/core'; @Module({}) export class ConfigModule { static forRoot(options: ConfigOptions): DynamicModule { return { module: ConfigModule, providers: [ { provide: 'CONFIG_OPTIONS', useValue: options, }, ConfigService, ], exports: [ConfigService], }; } } import { Module } from '@nl-framework/core'; @Module({ imports: [ ConfigModule.forRoot({ folder: './config', }), ], }) export class AppModule {} import { Module, DynamicModule } from '@nl-framework/core'; @Module({}) export class DatabaseModule { static forRootAsync(options: { useFactory: (...args: any[]) => Promise<DatabaseOptions>; inject?: any[]; }): DynamicModule { return { module: DatabaseModule, providers: [ { provide: 'DATABASE_OPTIONS', useFactory: options.useFactory, inject: options.inject || [], }, { provide: DatabaseConnection, useFactory: async (dbOptions) => { const connection = await createConnection(dbOptions); return connection; }, inject: ['DATABASE_OPTIONS'], }, DatabaseService, ], exports: [DatabaseService], }; } } import { Module } from '@nl-framework/core'; @Module({ imports: [ DatabaseModule.forRootAsync({ useFactory: (config: ConfigService) => ({ host: config.get('DB_HOST'), port: config.get('DB_PORT'), }), inject: [ConfigService], }), ], }) export class AppModule {} src/ app.module.ts main.ts users/ dto/ create-user.dto.ts update-user.dto.ts entities/ user.entity.ts users.controller.ts users.module.ts users.service.ts auth/ auth.controller.ts auth.module.ts auth.service.ts guards/ jwt.guard.ts strategies/ jwt.strategy.ts common/ decorators/ roles.decorator.ts guards/ roles.guard.ts interceptors/ logging.interceptor.ts A module is a class annotated with a @Module() decorator. The @Module() decorator provides metadata that Nael makes use of to organize the application structure. Each application has at least one module, a root module. The root module is the starting point Nael uses to build the application graph. The UsersController and UsersService belong to the same application domain. As they are closely related, it makes sense to move them into a feature module. A feature module simply organizes code relevant for a specific feature, keeping code organized and establishing clear boundaries. This helps us manage complexity and develop with SOLID principles, especially as the size of the application grows. We created users.module.ts and moved everything related to this module into the users directory. The last thing we need to do is import this module into the root module (the AppModule , defined in the app.module.ts file). In Nael, modules are singletons by default, and thus you can share the same instance of any provider between multiple modules effortlessly. Every module is automatically a shared module. Once created it can be reused by any module. Let&apos;s imagine that we want to share an instance of the ConfigService between several other modules. Now any module that imports the SharedModule has access to the ConfigService and will share the same instance with all other modules that import it as well. As seen above, Modules can export their internal providers. In addition, they can re-export modules that they import. In the example below, the ConfigModule is both imported into and exported from the CoreModule , making it available for other modules which import this one. A module class can inject providers as well (e.g., for configuration purposes): However, module classes themselves cannot be injected as providers due to circular dependency concerns. The Nael module system includes a powerful feature called dynamic modules. This feature enables you to easily create customizable modules that can register and configure providers dynamically. Dynamic modules are covered extensively in the Fundamentals chapter . Following is an example of a dynamic module definition for a ConfigModule : This module defines the ConfigService provider by default, but additionally - depending on the options object passed - exposes a collection of providers. Note that the properties of the object returned by the dynamic module extend (rather than override) the base module metadata defined in the @Module() decorator. Sometimes you may want to pass module options asynchronously instead of statically. In this case, use the forRootAsync() method, wh"
  },
  {
    "title": "Controllers · Nael Platform",
    "description": "Learn how to create and use controllers to handle incoming requests in Nael Platform.",
    "href": "/docs/controllers",
    "section": "controllers",
    "headings": [],
    "content": "import { Controller, Get } from '@nl-framework/http'; @Controller('users') export class UsersController { @Get() findAll(): string { return 'This action returns all users'; } } import { Controller, Get, Post } from '@nl-framework/http'; @Controller('users') export class UsersController { @Post() create(): string { return 'This action adds a new user'; } @Get() findAll(): string { return 'This action returns all users'; } } import { Controller, Get, Post, Put, Delete, Patch } from '@nl-framework/http'; @Controller('users') export class UsersController { @Post() create() {} @Get() findAll() {} @Get(':id') findOne(@Param('id') id: string) { return \\`This action returns user #\\${id}\\ @Put(':id') update() {} @Delete(':id') remove() {} @Patch(':id') patch() {} }`; @Get(':id') findOne(@Param('id') id: string): string { return \\`This action returns user #\\${id}\\ }`; import { Body, Post } from '@nl-framework/http'; class CreateUserDto { name: string; email: string; age: number; } @Post() create(@Body() createUserDto: CreateUserDto) { return 'This action adds a new user'; } import { Req } from '@nl-framework/http'; import { Request } from '@nl-framework/platform'; @Get() findAll(@Req() request: Request) { return request.headers; } @Get() async findAll(): Promise<User[]> { return await this.usersService.findAll(); } import { Post, HttpCode } from '@nl-framework/http'; @Post() @HttpCode(204) create() { return 'This action adds a new user'; } import { Post, Header } from '@nl-framework/http'; @Post() @Header('Cache-Control', 'no-store') create() { return 'This action adds a new user'; } import { Get, Redirect } from '@nl-framework/http'; @Get() @Redirect('https://nael.dev', 301) redirect() {} @Get('docs') @Redirect('https://docs.nael.dev', 302) getDocs(@Query('version') version) { if (version && version === '5') { return { url: 'https://docs.nael.dev/v5' }; } } @Controller({ host: ':account.example.com' }) export class AccountController { @Get() getInfo(@HostParam('account') account: string) { return account; } } Controllers are responsible for handling incoming requests and returning responses to the client. A controller&apos;s purpose is to receive specific requests for the application. The routing mechanism controls which controller receives which requests. In the following example we&apos;ll use the @Controller() decorator, which is required to define a basic controller. We&apos;ll specify an optional route path prefix of users. Using a path prefix in a @Controller() decorator allows us to easily group a set of related routes and minimize repetitive code. The @Get() HTTP request method decorator before the findAll() method tells Nael to create a handler for a specific endpoint for HTTP requests. The endpoint corresponds to the HTTP request method (GET in this case) and the route path. Handlers often need access to the client request details. Nael provides access to the request object. We can access the request object by instructing Nael to inject it by adding the @Req() decorator to the handler&apos;s signature. The request object represents the HTTP request and has properties for the request query string, parameters, HTTP headers, and body. In most cases, it&apos;s not necessary to grab these properties manually. We can use dedicated decorators instead, such as @Body() or @Query(). Earlier, we defined an endpoint to fetch users (GET route). We&apos;ll typically also want to provide an endpoint that creates new records. For this, let&apos;s create the POST handler: Nael provides decorators for all of the standard HTTP methods: @Get(), @Post(), @Put(), @Delete(), @Patch(), @Options(), and @Head(). In addition, @All() defines an endpoint that handles all of them. Pattern-based routes are supported as well. For instance, the asterisk is used as a wildcard, and will match any combination of characters: The &apos;abcd&apos; route path will match abcd, abcd, abecd, and so on. The characters ?, +, , and () may be used in a route path, and are subsets of their regular expression counterparts. As mentioned, the response status code is always 200 by default, except for POST requests which use 201. We can easily change this behavior by adding the @HttpCode(...) decorator at a handler level. To specify a custom response header, you can either use a @Header() decorator or a library-specific response object. To redirect a response to a specific URL, you can either use a @Redirect() decorator or a library-specific response object. @Redirect() takes two arguments, url and statusCode, both are optional. The default value of statusCode is 302 (Found) if omitted. Routes with static paths won&apos;t work when you need to accept dynamic data as part of the request (e.g., GET /users/1 to get user with id 1). In order to define routes with parameters, we can add route parameter tokens in the path of the route to capture the dynamic value at that position in the request URL. The @Controller decorator can take a host option to require that "
  },
  {
    "title": "Guards - NL Framework",
    "description": "Learn how to use guards for authorization and access control in NL Framework",
    "href": "/docs/guards",
    "section": "guards",
    "headings": [],
    "content": "import { CanActivate, HttpGuardExecutionContext } from '@nl-framework/http'; export class AuthGuard implements CanActivate { async canActivate(context: HttpGuardExecutionContext): Promise<boolean> { const request = context.getRequest(); const token = request.headers.authorization; if (!token) { return false; } try { const user = await this.validateToken(token); request.user = user; return true; } catch (error) { return false; } } private async validateToken(token: string) { return { id: 1, username: 'john' }; } } import { Controller, Get, UseGuards } from '@nl-framework/http'; @Controller('/api/users') export class UserController { @Get('/') @UseGuards(AuthGuard) async getUsers() { return { users: [] }; } @Get('/public') async getPublicData() { return { data: 'public' }; } } @Controller('/api/admin') @UseGuards(AuthGuard, AdminGuard) export class AdminController { @Get('/users') async getUsers() { return { users: [] }; } @Delete('/users/:id') async deleteUser(id: string) { return { deleted: true }; } } import { GuardFunction } from '@nl-framework/http'; const isAuthenticated: GuardFunction = async (context) => { const request = context.getRequest(); return !!request.headers.authorization; }; function hasRole(role: string): GuardFunction { return async (context) => { const request = context.getRequest(); return request.user?.role === role; }; } @Controller('/api/admin') export class AdminController { @Get('/dashboard') @UseGuards(isAuthenticated, hasRole('admin')) async getDashboard() { return { dashboard: {} }; } } import { createHttpApp, registerHttpGuard } from '@nl-framework/http'; async function bootstrap() { const app = await createHttpApp({ port: 3000 }); registerHttpGuard(AuthGuard); await app.start(); } import { SetMetadata } from '@nl-framework/core'; export const Roles = (...roles: string[]) => SetMetadata('roles', roles); @Injectable() export class RolesGuard implements CanActivate { async canActivate(context: HttpGuardExecutionContext): Promise<boolean> { const requiredRoles = context.getRoute().metadata?.roles as string[]; if (!requiredRoles) return true; const user = context.getRequest().user; return requiredRoles.some(role => user.roles?.includes(role)); } } @Controller('/api/admin') @UseGuards(AuthGuard, RolesGuard) export class AdminController { @Get('/users') @Roles('admin', 'superadmin') async getUsers() { return { users: [] }; } } Guards are a powerful mechanism for implementing authorization logic in your application. They determine whether a request should be handled by the route handler or not, making them perfect for authentication, authorization, and access control scenarios. 💡 Key Concept: Guards execute after all middleware but before pipes and route handlers . They have access to the full execution context and can make complex authorization decisions. Guards implement the CanActivate interface, which defines a single method: Guards can be applied to controllers or individual route handlers using the @UseGuards() decorator: For simple authorization logic, you can use functional guards instead of classes: Register guards globally to apply them to all routes: ✅ Summary: Guards provide a clean, declarative way to implement authorization logic. They execute after middleware but before pipes and handlers, support both class-based and functional implementations, and can be applied globally, per-controller, or per-route."
  },
  {
    "title": "Microservices & Scheduler · Techniques",
    "description": "Wire Dapr pub/sub, background jobs, and queue consumers inside Nael services.",
    "href": "/docs/techniques/microservices",
    "section": "techniques",
    "headings": [],
    "content": "bun add @nl-framework/microservices @nl-framework/scheduler dapr-client`; export const daprConsumer = `@Subscriber({ pubsubName: \"fleet-events\", topic: \"vehicle.assigned\", }) export class VehicleAssignedConsumer { constructor(private readonly logger: LoggerService) {} async handle(data: VehicleAssignedPayload) { this.logger.log(\"vehicle.assigned\", data) } } @Cron(\"0 */5 * * * *\", { name: \"warm-cache\" }) handleCacheWarmup() { return this.cache.prime() } @Interval(60_000) handleMetricsPush() { return this.metrics.flush() } dapr run \\ --app-id fleet-service \\ --app-port 3001 \\ --dapr-http-port 3500 \\ --components-path ./examples/microservices/dapr \\ -- bun run --cwd examples/microservices dev Scale beyond HTTP by leaning on the Dapr-friendly microservices module and the Bun Worker-based scheduler. Both ship decorators that feel like NestJS while embracing streaming-friendly transports. Add the microservices and scheduler packages to any service that needs async work. Dapr components are optional but recommended for durable pub/sub. Decorate a class with @Subscriber() to automatically register handlers with the Dapr sidecar. The framework handles signature validation, tracing, and poison queue retries. Cron, interval, and timeout decorators all run on Bun Workers so they don&apos;t block the main event loop. Each job automatically receives the DI container so you can inject repositories and services. Use the Dapr CLI to bootstrap pub/sub and state components locally. The microservices example already ships opinionated component YAMLs; copy them into your own repo or customize the topics."
  },
  {
    "title": "Database techniques · Nael Platform",
    "description": "Wire relational or document databases into Nael applications using DI-friendly modules and configuration.",
    "href": "/docs/techniques/database",
    "section": "techniques",
    "headings": [],
    "content": "import { Module } from '@nl-framework/core'; import { ConfigModule } from '@nl-framework/config'; import { createPool } from 'mysql2/promise'; export const MYSQL_POOL = Symbol('mysql:pool'); @Module({ imports: [ConfigModule.forRoot()], providers: [ { provide: MYSQL_POOL, useFactory: async (config: ConfigService) => { const credentials = config.get('database.mysql'); return createPool({ uri: credentials.url, connectionLimit: credentials.pool ?? 5, }); }, inject: [ConfigService], }, ], exports: [MYSQL_POOL], }) export class DatabaseModule {}; import { Inject, Injectable, Scope } from '@nl-framework/core'; @Injectable({ scope: Scope.REQUEST }) export class UsersRepository { constructor(@Inject(MYSQL_POOL) private readonly pool: Pool) {} async findById(id: string) { const [rows] = await this.pool.query('SELECT \\* FROM users WHERE id = ?', [id]); return rows[0] ?? null; } } import { Inject, Injectable } from '@nl-framework/core'; @Injectable() export class PaymentsService { constructor(@Inject(MYSQL_POOL) private readonly pool: Pool) {} async transfer(amount: number, from: string, to: string) { const connection = await this.pool.getConnection(); try { await connection.beginTransaction(); await connection.query('UPDATE accounts SET balance = balance - ? WHERE id = ?', [amount, from]); await connection.query('UPDATE accounts SET balance = balance + ? WHERE id = ?', [amount, to]); await connection.commit(); } catch (error) { await connection.rollback(); throw error; } finally { connection.release(); } } } Databases sit at the heart of most Nael applications. Whether you use raw drivers, query builders, or the first-class Nael ORM, the goal is the same: expose connections through dependency injection, scope transactional work per request, and keep configuration centralized. Store connection details in the configuration module , then register a provider that creates your database client or pool. Export the token so downstream modules can consume the same instance. Mark repositories as Scope.REQUEST when they need access to scoped metadata (tenant, auth context) or transactional state. Using the shared pool keeps connection counts stable while still letting you decorate per-request behavior. When working with raw drivers, keep transactions inside services so they can participate in the same DI graph as your controllers, guards, or jobs. Always release connections inside finally blocks and surface errors through domain exceptions. Nael ships an opinionated ORM with schema migrations, repositories, and multi-tenant helpers. This page covers low-level integration using raw drivers. For advanced scenarios—entity mapping, hooks, tenancy—head over to the dedicated guide. Explore the ORM docs →"
  },
  {
    "title": "Configuration · Nael Platform",
    "description": "Structure strongly typed configuration with ConfigModule, ConfigService, and feature slices.",
    "href": "/docs/techniques/configuration",
    "section": "techniques",
    "headings": [
      "config/production.yaml"
    ],
    "content": "import { ConfigModule } from '@nl-framework/config'; import { Module } from '@nl-framework/core'; @Module({ imports: [ ConfigModule.forRoot({ dir: 'config', path: 'env.yaml', overrides: { app: { host: '0.0.0.0', port: 4000 }, }, }), ], }) export class AppModule {} # config/default.yaml app: port: 3000 host: localhost features: cache: false # config/production.yaml app: port: 8080 features: cache: true import { Inject, Injectable, Module } from '@nl-framework/core'; import { ConfigModule, getConfigFeatureToken } from '@nl-framework/config'; const databaseConfigToken = getConfigFeatureToken('database'); @Injectable() class DatabaseClient { constructor(@Inject(databaseConfigToken) private readonly config: { url: string }) {} connect() { return connectToDatabase(this.config.url); } } @Module({ imports: [ ConfigModule.forFeature({ path: 'database', transform: (value) => ({ url: value.url ?? 'mongodb://localhost:27017/app', }), }), ], providers: [DatabaseClient], }) export class DatabaseModule {} ConfigModule.forRootAsync({ useFactory: async (secrets: SecretsService) => ({ dir: 'config', overrides: { database: { password: await secrets.get('db_password'), }, }, }), inject: [SecretsService], }); import { Injectable } from '@nl-framework/core'; import { ConfigService } from '@nl-framework/config'; @Injectable() export class AppService { constructor(private readonly config: ConfigService) {} port() { return this.config.get<number>('app.port', 3000); } featureEnabled(name: string) { return this.config.get<boolean>('app.features.' + name, false); } } Nael ships with a configuration module that layers YAML files, environment-specific overrides, and runtime factories into a single for different deployment targets. Register ConfigModule.forRoot() once near your root module. By default it looks for default.yaml, then , and finally env.yaml inside the provided directory. You can also inline overrides for values that should never live in source control. The loader deep-merges files in order. Production-specific keys override defaults, while missing keys fall back to the base file. Once the module is registered, inject ConfigService anywhere. Use get() with dot-paths to retrieve nested values and provide sensible defaults. Large apps benefit from injecting only the slice they need. ConfigModule.forFeature() publishes a token that resolves to a specific subtree (optionally transformed). This prevents unrelated modules from depending on the entire config object. When values originate from secret stores or other providers, use forRootAsync(). The factory receives injected dependencies and can return overrides or even different directories based on runtime signals."
  },
  {
    "title": "Serialization · Techniques",
    "description": "Control how responses are converted to JSON across HTTP and GraphQL using class-transformer with DI-driven settings.",
    "href": "/docs/techniques/serialization",
    "section": "techniques",
    "headings": [],
    "content": "# config/serialization.yaml serialization: enabled: true ttlMs: 0 # no cache here; just showing structure exposeUnsetFields: false groups: ['public'] import { Module, ConfigService } from '@nl-framework/core'; import { ConfigModule } from '@nl-framework/config'; import { Controller, Get, UseInterceptors } from '@nl-framework/http'; import { HttpSerializationInterceptor } from '@nl-framework/http'; import { SerializeOptions } from '@nl-framework/core'; export const HTTP_SERIALIZER = Symbol('serializer:http'); @Controller('/users') @UseInterceptors(HTTP_SERIALIZER) @SerializeOptions({ groups: ['public'] }) export class UsersController { @Get('/') list() { return this.service.all(); // class instances are transformed to plain JSON } @Get('/admin') @SerializeOptions({ groups: ['admin'] }) adminView() { return this.service.all(); // per-handler overrides } } @Module({ imports: [ConfigModule.forRoot()], controllers: [UsersController], providers: [ { provide: HTTP_SERIALIZER, inject: [ConfigService], useFactory: (config: ConfigService<{ serialization: any }>) => new HttpSerializationInterceptor({ transformOptions: { groups: config.get('serialization.groups', ['public']) as string[], exposeUnsetFields: false, }, }), }, ], }) export class UsersModule {} import { Module, ConfigService } from '@nl-framework/core'; import { ConfigModule } from '@nl-framework/config'; import { Resolver, Query } from '@nl-framework/graphql'; import { UseInterceptors } from '@nl-framework/http'; import { GraphqlSerializationInterceptor } from '@nl-framework/graphql'; import { SerializeOptions } from '@nl-framework/core'; export const GQL_SERIALIZER = Symbol('serializer:graphql'); @Resolver() @UseInterceptors(GQL_SERIALIZER) @SerializeOptions({ groups: ['public'] }) export class ReportsResolver { @Query(() => [Report]) reports() { return this.service.list(); // returns DTO instances } } @Module({ imports: [ConfigModule.forRoot()], providers: [ ReportsResolver, { provide: GQL_SERIALIZER, inject: [ConfigService], useFactory: (config: ConfigService<{ serialization: any }>) => new GraphqlSerializationInterceptor({ transformOptions: { groups: config.get('serialization.groups', ['public']) as string[], }, }), }, ], }) export class ReportsModule {} import { serialize, SerializeOptions } from '@nl-framework/core'; @SerializeOptions({ groups: ['public'] }) class UserView { id!: string; email!: string; passwordHash!: string; } export function toPublicJson(user: UserView) { return serialize(user, { groups: ['public'] }); } Techniques Shape your JSON responses with class-transformer. Nael provides a shared serialize() helper, a @SerializeOptions() decorator for per-handler control, and HTTP/GraphQL interceptors that respect DI config. Streams, buffers, and Response objects are passed through unchanged. Keep serialization defaults in ConfigModule so interceptors can read groups or strategies without hardcoding. Use Symbols to register interceptors in the container and reuse across controllers or resolvers. Attach HttpSerializationInterceptor globally or per-controller. Combine with @SerializeOptions() to set class-transformer groups or naming strategies per handler. Wrap resolvers with GraphqlSerializationInterceptor to convert DTO instances into plain objects before they hit Apollo. Skip primitives automatically; only objects/arrays are transformed. Use serialize() directly in jobs or microservices when you need the same rules outside HTTP/GraphQL. Decorate classes with @SerializeOptions() to keep group-aware transforms close to the DTO."
  },
  {
    "title": "Task scheduling · Techniques",
    "description": "Run cron, interval, and timeout jobs in Bun workers with decorator-driven registration.",
    "href": "/docs/techniques/task-scheduling",
    "section": "techniques",
    "headings": [],
    "content": "bun add @nl-framework/scheduler @nl-framework/logger`; export const schedulerModule = `import { Module, Injectable, OnModuleInit } from '@nl-framework/core'; import { Logger } from '@nl-framework/logger'; import { Cron, Interval, Timeout, SchedulerModule, SchedulerService } from '@nl-framework/scheduler'; @Injectable() export class ReportsScheduler implements OnModuleInit { constructor( private readonly scheduler: SchedulerService, private readonly logger: Logger, ) {} // Runs every minute, immediately after registration @Cron('0 \\* \\* \\* \\* \\*', { name: 'reports.generate', runOnInit: true }) async generateReport() { this.logger.info('Generating scheduled report'); } // Fixed interval with max runs @Interval(15_000, { name: 'reports.cleanup', maxRuns: 10 }) async cleanup() { this.logger.info('Cleaning up temporary report files'); } // One-off timeout @Timeout(5_000, { name: 'reports.seed' }) async seed() { this.logger.info('Seeding initial reports'); } async onModuleInit() { await this.scheduler.registerDecoratedTarget(this); } } @Module({ imports: [SchedulerModule], providers: [ReportsScheduler], }) export class ReportsModule {} import { Injectable } from '@nl-framework/core'; import { SchedulerService } from '@nl-framework/scheduler'; import { Logger } from '@nl-framework/logger'; @Injectable() export class AdHocTasksService { constructor( private readonly scheduler: SchedulerService, private readonly logger: Logger, ) {} async startPulse() { const handle = await this.scheduler.scheduleInterval( 'diagnostics.pulse', async () => this.logger.debug('Pulse tick'), { interval: 5_000, runOnInit: true }, ); return handle; } async stop(name: string) { await this.scheduler.cancel(name); } } # config/scheduler.yaml (optional) scheduler: timezone: UTC          # apply when building cron expressions manually logging: true          # use logger transport runOnInit: false       # default for decorators if you wish to override per env Techniques Offload cron-like and interval work to a dedicated Bun worker. Use decorators for static jobs, the scheduler service for dynamic tasks, and keep your main event loop responsive. Add the scheduler package and logger (for structured job output). Import SchedulerModule in the module that hosts your jobs. Decorate methods with @Cron, @Interval, or @Timeout. Call registerDecoratedTarget in onModuleInit so jobs are registered when the module boots. Jobs execute inside a worker for accurate timers. Use SchedulerService directly for feature-flagged or user-driven schedules. Every registration returns a handle that can be cancelled later. The scheduler itself is configuration-light; you can still centralize flags (like default runOnInit or timezones) in your config module and inject values into your schedulers or factories. Explore the runnable example at examples/scheduler or the API docs in"
  },
  {
    "title": "GraphQL & Federation · Techniques",
    "description": "Guidance for running GraphQL servers, Apollo subgraphs, and Bun-based gateways.",
    "href": "/docs/techniques/graphql",
    "section": "techniques",
    "headings": [],
    "content": "bun add @nl-framework/graphql @apollo/subgraph @as-integrations/bun-http`; export const gatewayConfig = `NaelFactory.create(FederationGatewayModule.forRoot({ supergraphSdl: readFileSync(\"./supergraph.graphql\", \"utf8\"), pollingInterval: 2000, buildService: () => new RemoteGraphQLDataSource({ willSendRequest({ request, context }) { request.http?.headers.set(\"x-tenant\", context.tenantId) }, }), })); @Resolver(() => Fleet) export class FleetResolver { constructor(private readonly service: FleetService) {} @ResolveReference() resolveReference(ref: FleetReference) { return this.service.lookup(ref.id) } } const app = await NaelFactory.create(GraphQLModule.forRoot({ autoSchemaFile: join(process.cwd(), \"schema.gql\"), playground: process.env.NODE_ENV !== \"production\", context: ({ req, res }) => ({ req, res, requestId: randomUUID() }), plugins: [BetterAuthGraphQLPlugin], })); await app.listen(); Build monolith schemas or stitch multiple subgraphs without leaving Bun. Nael offers batteries-included modules for Apollo Federation v2, data loaders, persisted queries, and Better Auth-aware contexts. Each example depends on @nl-framework/graphql plus the official Apollo subgraph runtime and Bun&apos;s HTTP integration layer. Bootstrap a schema once and reuse across HTTP + WebSocket transports. The factory wires context objects, converters, and introspection defaults for you. Use the federation helper to convert standard resolvers into reference resolvers. Schema directives and custom scalars are auto-registered via the module metadata. The examples/federation-gateway folder demonstrates a Bun-native Apollo Gateway. Poll Uplink or self-hosted supergraphs and push tenant metadata through headers."
  },
  {
    "title": "File upload · Techniques",
    "description": "Handle multipart/form-data uploads in Nael HTTP handlers using native FormData APIs.",
    "href": "/docs/techniques/file-upload",
    "section": "techniques",
    "headings": [],
    "content": "import { Controller, Post, Req } from '@nl-framework/http'; @Controller('/upload') export class UploadController { @Post('/') async upload(@Req() req: Request) { const form = await req.formData(); const file = form.get('file'); if (!(file instanceof File)) { return new Response(JSON.stringify({ error: 'file is required' }), { status: 400, headers: { 'content-type': 'application/json' }, }); } if (file.size > 5 * 1024 * 1024) { return new Response(JSON.stringify({ error: 'File too large' }), { status: 413, headers: { 'content-type': 'application/json' }, }); } const buffer = await file.arrayBuffer(); // persist buffer to disk/object storage here return { name: file.name, size: file.size, type: file.type }; } } @Post('/stream') async stream(@Req() req: Request) { const form = await req.formData(); const file = form.get('file'); if (!(file instanceof File)) { return new Response('file required', { status: 400 }); } // Stream to storage without buffering entire file const reader = file.stream().getReader(); while (true) { const chunk = await reader.read(); if (chunk.done) break; await writeChunk(chunk.value); // your storage writer } return { ok: true }; } @Post('/multi') async multi(@Req() req: Request) { const form = await req.formData(); const files = form.getAll('files').filter((f): f is File => f instanceof File); if (!files.length) { return new Response(JSON.stringify({ error: 'No files uploaded' }), { status: 400, headers: { 'content-type': 'application/json' }, }); } const meta = files.map((f) => ({ name: f.name, size: f.size, type: f.type })); return { count: files.length, files: meta }; } import { GraphQLUpload, FileUpload } from 'graphql-upload'; import { Resolver, Mutation, Arg } from '@nl-framework/graphql'; import { UseInterceptors } from '@nl-framework/http'; @Resolver() export class MediaResolver { @Mutation(() => Boolean) async uploadImage( @Arg('file', () => GraphQLUpload) file: Promise<FileUpload>, ): Promise<boolean> { const { createReadStream, filename, mimetype } = await file; const stream = createReadStream(); await saveStreamToStorage(stream, filename, mimetype); // your storage client return true; } } // When bootstrapping Apollo/Nael GraphQL, ensure graphql-upload middleware is applied to the HTTP server. // In Bun, wrap the request handler with processRequest from graphql-upload when content-type is multipart/form-data. import { Inject, Injectable } from '@nl-framework/core'; import { ConfigModule, ConfigService } from '@nl-framework/config'; import { AzureBlobStorageAdapter, S3StorageAdapter, createStorageModule, STORAGE_ADAPTER, type StorageAdapter, } from '@nl-framework/storage'; // Build a StorageModule using ConfigModule to pick the adapter export const StorageModule = createStorageModule({ imports: [ConfigModule.forRoot()], inject: [ConfigService], useFactory: (config: ConfigService) => { if (config.get('storage.provider') === 'azure') { return new AzureBlobStorageAdapter({ accountName: config.get('storage.azure.accountName') as string, accountKey: config.get('storage.azure.accountKey') as string, container: config.get('storage.azure.container', 'uploads') as string, }); } return new S3StorageAdapter({ bucket: config.get('storage.s3.bucket') as string, region: config.get('storage.s3.region') as string, credentials: { accessKeyId: config.get('storage.s3.accessKeyId') as string, secretAccessKey: config.get('storage.s3.secretAccessKey') as string, }, urlPrefix: config.get('storage.s3.urlPrefix') as string | undefined, }); }, }); @Injectable() export class UploadsService { constructor(@Inject(STORAGE_ADAPTER) private readonly storage: StorageAdapter) {} async save(key: string, file: File) { const buffer = Buffer.from(await file.arrayBuffer()); return this.storage.uploadObject(key, buffer, { contentType: file.type }); } } // config/storage.yaml // storage: // provider: s3 // s3: // bucket: my-bucket // region: us-east-1 // accessKeyId: ... // secretAccessKey: ... // urlPrefix: https://my-bucket.s3.us-east-1.amazonaws.com Techniques Nael doesn&apos;t bundle Multer or busboy. Instead, use the platform-native Request.formData() to access uploaded File objects, then stream or buffer them to storage. Read FormData from the request, validate size and presence, then persist. Keep JSON responses for clients expecting structured metadata. For large files, stream chunks from file.stream() into your storage client to avoid buffering the entire payload in memory. Use formData.getAll() for multi-file inputs and iterate over File instances. Pair with compression for downloads and caching where appropriate. Use graphql-upload with the Nael GraphQL stack. Register the middleware on the HTTP server for multipart requests and use the GraphQLUpload scalar in your schema. Resolver receives a FileUpload with createReadStream() for streaming to storage. Use the @nl-framework/storage adapters and wire them through ConfigModule. Provide the adapter once via createStorageModule, inject the exported token, an"
  },
  {
    "title": "Compression · Techniques",
    "description": "Add response compression with HTTP middleware in Nael applications using Bun",
    "href": "/docs/techniques/compression",
    "section": "techniques",
    "headings": [],
    "content": "import { MiddlewareHandler } from '@nl-framework/http'; export const compressionMiddleware: MiddlewareHandler = async (ctx, next) => { const res = await next(); const acceptEncoding = ctx.request.headers.get('accept-encoding') ?? ''; if (!acceptEncoding.includes('gzip')) { return res; } const contentType = res.headers.get('content-type') ?? ''; if (!contentType.includes('application/json')) { return res; } const text = await res.text(); const compressed = Bun.gzipSync(Buffer.from(text)); const headers = new Headers(res.headers); headers.set('content-encoding', 'gzip'); headers.set('content-length', compressed.length.toString()); return new Response(compressed, { status: res.status, statusText: res.statusText, headers, }); }; import { NaelFactory } from '@nl-framework/platform'; const app = await NaelFactory.create(AppModule); const http = app.getHttpApplication(); if (http) { http.use(compressionMiddleware); } await app.listen({ http: 3000 }); // For streams, pre-compress assets or use Bun.gzipSync on Buffers before sending. // Avoid buffering huge streams in memory; prefer CDN/static hosting for large files. Techniques Use HTTP middleware to gzip JSON responses when clients advertise support. Nael does not bundle a compressor by default; Bun&apos;s gzipSync makes it straightforward to add. Inspect Accept-Encoding and compress JSON bodies on the fly. Skip other content types to avoid double-compressing binaries. For large files or streams, pre-compress assets or serve through a CDN that handles compression. Avoid buffering giant payloads in memory just to gzip them. For more middleware patterns, see Middleware ."
  },
  {
    "title": "Queues (Dapr) · Techniques",
    "description": "Use Dapr pub/sub with the Nael microservices module to publish and consume queue-like workloads without extra brokers.",
    "href": "/docs/techniques/queues",
    "section": "techniques",
    "headings": [],
    "content": "bun add @nl-framework/microservices @nl-framework/logger`; export const daprConfig = `# components/pubsub.yaml (Dapr) apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: redis-pubsub spec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 import { Module, Injectable } from '@nl-framework/core'; import { Logger } from '@nl-framework/logger'; import { MicroservicesModule, EventPattern, createMicroservicesModule } from '@nl-framework/microservices'; @Injectable() export class OrdersConsumer { constructor(private readonly logger: Logger) {} @EventPattern('orders.created') async handleCreated(payload: { id: string; total: number }) { this.logger.info('Processing order', payload); } } @Module({ imports: [ createMicroservicesModule({ // Defaults: daprHost=localhost, daprHttpPort=3500, pubsubName=redis-pubsub controllers: [OrdersConsumer], }), ], providers: [OrdersConsumer], }) export class OrdersModule {} import { Injectable } from '@nl-framework/core'; import { MicroserviceClient } from '@nl-framework/microservices'; @Injectable() export class OrdersService { constructor(private readonly client: MicroserviceClient) {} async publishOrder(order: { id: string; total: number }) { await this.client.emit('orders.created', order); // fire-and-forget to Dapr pubsub } async getInvoice(id: string) { // Request/response via Dapr service invocation // Pattern format: \"app:method\" or { app, method } return this.client.send<{ invoiceUrl: string }>('billing:get-invoice', { orderId: id }); } } # terminal 1: start Dapr sidecar with pubsub component mounted dapr run --app-id orders-api --app-port 3000 --components-path ./components -- bun run dev Techniques Ship background work and fan-out flows through Dapr pub/sub. The microservices module wraps the Dapr HTTP API, exposing simple decorators for consumers and a client for producers—no BullMQ or custom brokers required. Add the microservices package and a Dapr pub/sub component (Redis in this example). The default pubsub name is redis-pubsub; override via DaprTransportOptions if needed. Decorate methods with @EventPattern to subscribe to topics. Import createMicroservicesModule to bootstrap the Dapr transport and register handlers automatically. Inject MicroserviceClient and call emit() to publish to a topic. For request/response, use send() which maps to Dapr service invocation (pattern app:method or an object with app/method keys)."
  },
  {
    "title": "Better Auth · Techniques",
    "description": "Best practices for wiring Better Auth across HTTP, GraphQL, and multi-tenant services.",
    "href": "/docs/techniques/better-auth",
    "section": "techniques",
    "headings": [],
    "content": "bun add @nl-framework/auth better-auth @better-auth/bun`; export const httpProxy = `import { BetterAuthProxyModule } from \"@nl-framework/auth\"; @Module({ imports: [BetterAuthProxyModule.forRoot({ upstreamUrl: \"https://auth.nael.dev\", cookieDomain: \".nael.dev\", })], }) export class HttpModule {} @Resolver(() => Profile) export class ProfileResolver { constructor(private readonly service: ProfileService) {} @UseGuards(BetterAuthGuard) @Query(() => Profile) me(@CurrentSession() session: BetterAuthSession) { return this.service.resolveProfile(session.userId); } } BetterAuthMultiTenantFactory.register({ async resolveTenant(ctx) { return tenants.find((tenant) => tenant.domain === ctx.req.host) }, async secretsFor(tenant) { return { cookieName: \\`__Secure-\\${tenant.key}\\`, secret: tenant.secret, } }, }); Better Auth is treated as a first-class citizen: proxy the hosted routes, share session middleware across transports, and hydrate tenant-specific secrets on the fly. This guide distills how the examples wire everything together. Start with the auth package plus the upstream Better Auth SDKs. Every provider is tree-shakeable and compatible with Bun&apos;s native fetch implementation. Reuse the hosted Better Auth router by proxying it through the Bun server. Attach the module to the same Nest-like DI container so guards share context. Wrap resolvers with BetterAuthGuard and inject the session using @CurrentSession(). The guard reads the same cookies set by the proxy module. The auth-multi-tenant- examples register a resolver that inspects the incoming host header, resolves a tenant, and loads individual Better Auth cookies + secrets. Each tenant can map to its own project inside the Better Auth dashboard."
  },
  {
    "title": "ORM docs moved · Nael Platform",
    "description": "This page now lives under the dedicated ORM section.",
    "href": "/docs/techniques/orm",
    "section": "techniques",
    "headings": [],
    "content": ""
  },
  {
    "title": "Versioning · Techniques",
    "description": "Expose multiple API versions with route decorators and configurable negotiation strategies.",
    "href": "/docs/techniques/versioning",
    "section": "techniques",
    "headings": [
      "Custom header strategy",
      "Media type strategy (if enabled)"
    ],
    "content": "# config/http.yaml http: port: 3000 versioning: enabled: true strategies: ['uri', 'header'] defaultVersion: '1' headerName: x-api-version uriPrefix: v responseHeader: api-version import { createHttpApplication } from '@nl-framework/http'; await createHttpApplication(AppModule, { port: 3000, versioning: { enabled: true, strategies: ['uri', 'header'], defaultVersion: '1', responseHeader: 'api-version', }, }).then((app) => app.listen()); import { Controller, Get, Version } from '@nl-framework/http'; @Controller('/users') @Version('1') // default for the controller export class UsersController { @Get('/') listV1() { return [{ id: 1, email: 'ada@example.com' }]; } @Get('/') @Version('2') listV2() { return [{ id: 1, email: 'ada@example.com', active: true }]; } @Get('/:id') @Version(['1', '2']) detail() { return { id: 1, email: 'ada@example.com' }; } } # URI strategy (/v1 prefix) curl http://localhost:3000/v1/users # Custom header strategy curl -H \"x-api-version: 2\" http://localhost:3000/users # Media type strategy (if enabled) curl -H \"accept: application/json;v=2\" http://localhost:3000/users Techniques Serve multiple API versions side by side. Nael lets you declare versions on controllers or handlers and negotiate them via URI prefixes, custom headers, or media-type parameters—all configurable through DI-friendly options at bootstrap. Enable versioning per HTTP app. Choose strategies, default version, and the response header that surfaces the negotiated version. URI strategy strips a prefix like /v1; header strategy reads x-api-version; media strategy looks for v in Accept. Use @Version() on controllers for defaults and on handlers for overrides. The router picks the best match for the requested version and falls back to unversioned routes when no specific match exists. With URI strategy, prefix routes (e.g., /v1/users). With header/media strategies, keep URLs stable and pass version metadata in headers."
  },
  {
    "title": "Events · Techniques",
    "description": "Publish and handle domain events using the Nael microservices module and Dapr pub/sub.",
    "href": "/docs/techniques/events",
    "section": "techniques",
    "headings": [],
    "content": "bun add @nl-framework/microservices @nl-framework/logger`; export const daprComponent = `# components/pubsub.yaml apiVersion: dapr.io/v1alpha1 kind: Component metadata: name: redis-pubsub spec: type: pubsub.redis version: v1 metadata: - name: redisHost value: localhost:6379 import { Module, Injectable } from '@nl-framework/core'; import { Logger } from '@nl-framework/logger'; import { EventPattern, createMicroservicesModule } from '@nl-framework/microservices'; @Injectable() export class NotificationsConsumer { constructor(private readonly logger: Logger) {} @EventPattern('notifications.email') async handleEmail(payload: { to: string; subject: string }) { this.logger.info('Sending email', payload); } @EventPattern({ topic: 'notifications.sms' }) async handleSms(payload: { to: string; message: string }) { this.logger.info('Sending SMS', payload); } } @Module({ imports: [ createMicroservicesModule({ controllers: [NotificationsConsumer], // transport defaults to Dapr pub/sub (redis-pubsub on localhost:3500) }), ], providers: [NotificationsConsumer], }) export class NotificationsModule {}; import { Injectable } from '@nl-framework/core'; import { MicroserviceClient } from '@nl-framework/microservices'; @Injectable() export class OrdersService { constructor(private readonly client: MicroserviceClient) {} async place(order: { id: string; total: number }) { // ...persist the order... await this.client.emit('notifications.email', { to: 'user@example.com', subject: 'Order received', }); } } dapr run --app-id notifications --app-port 4000 --components-path ./components -- bun run dev`; <article className=\"space-y-8\"> <div className=\"space-y-3\"> <Badge className=\"bg-violet-100 text-violet-900 dark:bg-violet-900/30 dark:text-violet-50\"> Techniques </Badge> <h1 className=\"text-4xl font-semibold tracking-tight\">Events</h1> <div className=\"text-lg text-muted-foreground\"> Decouple services with domain events. Nael uses the microservices module with Dapr pub/sub by default, giving you decorators for consumers and a simple client for producers. </div> </div> <section className=\"space-y-4\" id=\"install\"> <h2 className=\"text-2xl font-semibold\">Install & configure Dapr</h2> <div className=\"text-muted-foreground\"> Add the microservices package and run a Dapr sidecar with a pub/sub component (Redis shown here). Override `pubsubName`, host, or port via `DaprTransportOptions` when creating the microservices module. </div> <CodeBlock code={install} title=\"Install dependencies\" /> <CodeBlock code={daprComponent} title=\"Dapr pub/sub component\" /> <CodeBlock code={runDapr} title=\"Run Dapr sidecar\" /> </section> <section className=\"space-y-4\" id=\"consume\"> <h2 className=\"text-2xl font-semibold\">Handle events with decorators</h2> <div className=\"text-muted-foreground\"> Use `@EventPattern` to subscribe to topics. Register controllers through `createMicroservicesModule` so handlers are discovered and wired to the Dapr transport. </div> <CodeBlock code={consumer} title=\"notifications.module.ts\" /> </section> <section className=\"space-y-4\" id=\"produce\"> <h2 className=\"text-2xl font-semibold\">Publish events</h2> <div className=\"text-muted-foreground\"> Inject `MicroserviceClient` and call `emit()` for fire-and-forget events. For request/response, use `send()` (Dapr service invocation) when you need a reply. </div> <CodeBlock code={producer} title=\"orders.service.ts\" /> </section> <section className=\"space-y-3\" id=\"tips\"> <h2 className=\"text-2xl font-semibold\">Best practices</h2> <ul className=\"list-disc space-y-2 pl-6 text-muted-foreground\"> <li>Keep events small and idempotent; Dapr may redeliver on failures.</li> <li>Use stable topic names per bounded context (e.g., <code>orders.created</code>).</li> <li>Log and handle poison messages—DLQ support can be added via Dapr component config.</li> <li>Set transport options via config to target different pub/sub backends per environment.</li> <li>Combine with <Link className=\"text-primary underline\" href=\"/docs/techniques/logging\">logging</Link> for traceability across services.</li> </ul> </section> </article> Techniques Decouple services with domain events. Nael uses the microservices module with Dapr pub/sub by default, giving you decorators for consumers and a simple client for producers. Add the microservices package and run a Dapr sidecar with a pub/sub component (Redis shown here). Override pubsubName, host, or port via DaprTransportOptions when creating the microservices module. Use @EventPattern to subscribe to topics. Register controllers through createMicroservicesModule so handlers are discovered and wired to the Dapr transport. Inject MicroserviceClient and call emit() for fire-and-forget events. For request/response, use send() (Dapr service invocation) when you need a reply."
  },
  {
    "title": "Caching · Techniques",
    "description": "Add response caching to HTTP and GraphQL handlers with pluggable stores and Redis support.",
    "href": "/docs/techniques/caching",
    "section": "techniques",
    "headings": [],
    "content": "# config/cache.yaml cache: ttlMs: 60000 prefix: api redisUrl: \\${REDIS_URL} maxEntries: 500 import Redis from 'ioredis'; import { Module, ConfigService, Inject } from '@nl-framework/core'; import { buildCacheKey, InMemoryCacheStore, RedisCacheStore, type CacheStore } from '@nl-framework/core'; import { ConfigModule } from '@nl-framework/config'; import { Controller, Get, UseInterceptors, HttpCacheInterceptor } from '@nl-framework/http'; export const CACHE_STORE = Symbol('cache:store'); export const CACHE_INTERCEPTOR = Symbol('cache:interceptor'); @Controller('/posts') @UseInterceptors(CACHE_INTERCEPTOR) export class PostsController { constructor(private readonly service: PostsService) {} @Get('/') list() { return this.service.listPublished(); } } @Module({ imports: [ConfigModule.forRoot()], controllers: [PostsController], providers: [ { provide: CACHE_STORE, inject: [ConfigService], useFactory: (config: ConfigService<{ cache: any }>): CacheStore => { const ttl = config.get('cache.ttlMs', 30_000) as number; const prefix = config.get('cache.prefix', 'api') as string; const redisUrl = config.get('cache.redisUrl') as string | undefined; const maxEntries = config.get('cache.maxEntries', 500) as number; if (redisUrl) { const client = new Redis(redisUrl); return new RedisCacheStore(client, { prefix, ttl }); } return new InMemoryCacheStore({ ttl, maxEntries }); }, }, { provide: CACHE_INTERCEPTOR, inject: [CACHE_STORE, ConfigService], useFactory: (store: CacheStore, config: ConfigService<{ cache: any }>) => new HttpCacheInterceptor({ store, ttl: config.get('cache.ttlMs', 30_000) as number, key: (ctx) => buildCacheKey('posts', ctx.getRequest().url), }), }, ], }) export class PostsModule {} import { Module, ConfigService } from '@nl-framework/core'; import { buildCacheKey, InMemoryCacheStore } from '@nl-framework/core'; import { ConfigModule } from '@nl-framework/config'; import { Resolver, Query } from '@nl-framework/graphql'; import { UseInterceptors } from '@nl-framework/http'; import { GraphqlCacheInterceptor } from '@nl-framework/graphql'; export const GRAPHQL_CACHE = Symbol('cache:graphql'); @Resolver() @UseInterceptors(GRAPHQL_CACHE) export class ReportsResolver { @Query(() => [String]) recentReports() { return this.service.list(); } } @Module({ imports: [ConfigModule.forRoot()], providers: [ ReportsResolver, { provide: GRAPHQL_CACHE, inject: [ConfigService], useFactory: (config: ConfigService<{ cache: any }>) => { const store = new InMemoryCacheStore({ ttl: config.get('cache.ttlMs', 15_000) as number }); return new GraphqlCacheInterceptor({ store, ttl: config.get('cache.ttlMs', 15_000) as number, key: (ctx) => buildCacheKey('reports', ctx.getResolverHandlerName(), ctx.getArgs()), }); }, }, ], }) export class ReportsModule {} import Redis from 'ioredis'; import { Module, ConfigService } from '@nl-framework/core'; import { RedisCacheStore } from '@nl-framework/core'; import { ConfigModule } from '@nl-framework/config'; import { Controller, Get, UseInterceptors, HttpCacheInterceptor } from '@nl-framework/http'; export const CACHE_STORE = Symbol('cache:store'); export const CACHE_INTERCEPTOR = Symbol('cache:interceptor'); @Controller('/products') @UseInterceptors(CACHE_INTERCEPTOR) export class ProductsController { @Get('/') list() { return this.service.all(); } } @Module({ imports: [ConfigModule.forRoot()], controllers: [ProductsController], providers: [ { provide: CACHE_STORE, inject: [ConfigService], useFactory: (config: ConfigService<{ cache: any }>) => { const client = new Redis(config.get('cache.redisUrl', process.env.REDIS_URL!) as string); return new RedisCacheStore(client, { prefix: config.get('cache.prefix', 'api') as string, ttl: config.get('cache.ttlMs', 60_000) as number, }); }, }, { provide: CACHE_INTERCEPTOR, inject: [CACHE_STORE, ConfigService], useFactory: (store, config: ConfigService<{ cache: any }>) => new HttpCacheInterceptor({ store, ttl: config.get('cache.ttlMs', 60_000) as number, }), }, ], }) export class ProductsModule {} import { buildCacheKey, InMemoryCacheStore } from '@nl-framework/core'; const cache = new InMemoryCacheStore({ ttl: 10_000 }); export async function fetchProfile(id: string) { const key = buildCacheKey('profile', id); const cached = await cache.get(key); if (cached) { return cached; } const profile = await queryDatabase(id); await cache.set(key, profile, { ttl: 10_000 }); return profile; } export async function invalidateProfile(id: string) { await cache.delete(buildCacheKey('profile', id)); } Techniques Cache expensive responses without coupling your handlers to storage details. Nael ships a CacheStore interface, an in-memory LRU implementation, Redis adapter, and cache interceptors for both HTTP and GraphQL pipelines. Keys are stable via buildCacheKey(), TTLs are millisecond-based, and you stay in control of what gets cached. Drive cache settings from ConfigModule and expose stores/interceptors as providers. The examples below use Symbols so @UseInterceptors() can reso"
  },
  {
    "title": "Logging · Techniques",
    "description": "Structured logging with DI-friendly factories, request middleware, and transport customization in Nael.",
    "href": "/docs/techniques/logging",
    "section": "techniques",
    "headings": [],
    "content": "import { NaelFactory } from '@nl-framework/platform'; import { Logger } from '@nl-framework/logger'; const appLogger = new Logger({ context: 'orders-api', level: (process.env.LOG_LEVEL as any) ?? 'INFO', }); const app = await NaelFactory.create(AppModule, { logger: appLogger }); await app.listen({ http: 3000 }); import { MiddlewareHandler } from '@nl-framework/http'; import { LoggerFactory } from '@nl-framework/logger'; export const createRequestLogger = async (loggerFactory: LoggerFactory): Promise<MiddlewareHandler> => { const logger = loggerFactory.create({ context: 'HttpRequest' }); return async (ctx, next) => { const start = Date.now(); try { const res = await next(); logger.info('Handled request', { method: ctx.request.method, path: new URL(ctx.request.url).pathname, status: res.status, elapsedMs: Date.now() - start, }); return res; } catch (error) { logger.error('Request failed', error instanceof Error ? error : undefined, { method: ctx.request.method, path: new URL(ctx.request.url).pathname, elapsedMs: Date.now() - start, }); throw error; } }; }; import { Injectable } from '@nl-framework/core'; import { LoggerFactory } from '@nl-framework/logger'; @Injectable() export class BillingService { private readonly logger = this.loggerFactory.create({ context: 'Billing' }); constructor(private readonly loggerFactory: LoggerFactory) {} async charge(customerId: string, amount: number) { const op = this.logger.child('Charge', { level: 'INFO' }); op.info('Initiating charge', { customerId, amount }); // ... op.info('Charge complete', { customerId, amount }); } } import { Logger, type LogMessage, type LoggerTransport } from '@nl-framework/logger'; class HttpTransport implements LoggerTransport { async log(entry: LogMessage) { await fetch('https://logs.example.com/ingest', { method: 'POST', headers: { 'content-type': 'application/json' }, body: JSON.stringify(entry), }); } } const logger = new Logger({ transports: [new HttpTransport()], context: 'jobs' }); logger.info('Job started'); import apm from 'elastic-apm-node'; import { Logger, type LogMessage, type LoggerTransport } from '@nl-framework/logger'; apm.start({ serviceName: 'orders-api', serverUrl: process.env.ELASTIC_APM_SERVER_URL, secretToken: process.env.ELASTIC_APM_SECRET_TOKEN, environment: process.env.NODE_ENV ?? 'development', }); class ElasticApmTransport implements LoggerTransport { log(entry: LogMessage) { // Avoid blocking; Elastic APM agent batches internally const span = apm.currentSpan || apm.startSpan(entry.context ?? 'log'); if (span) { span.addLabels({ level: entry.level.toLowerCase(), message: entry.message, ...(entry.meta ?? {}), }); span.end(); } if (entry.error instanceof Error) { apm.captureError(entry.error, { handled: true, custom: { context: entry.context, ...entry.meta, }, }); } } } const logger = new Logger({ context: 'orders-api', transports: [new ElasticApmTransport()], }); logger.info('Booting service'); Techniques Emit structured logs across HTTP handlers, schedulers, and microservices. Nael&apos;s logger ships with JSON output, child contexts, and pluggable transports so you can route logs to stdout, files, or remote collectors. Provide a root Logger when bootstrapping your app to set the service name and log level. Downstream modules receive the same factory to create context-specific children. Add an HTTP middleware that logs method, path, status, and latency. Use LoggerFactory to keep contextual loggers scoped to the request pipeline. Inject LoggerFactory into services and create child loggers per operation or tenant. Child loggers inherit transports and levels unless you override them. The default console transport prints JSON to stdout. Implement LoggerTransport to forward logs to HTTP collectors, files, or observability backends. For Elastic APM, start the agent once and implement a transport that adds log metadata as span labels and captures errors:"
  },
  {
    "title": "Cookies · Techniques",
    "description": "Read and write HTTP cookies safely in Nael apps, including multi-tenant prefixes with Better Auth.",
    "href": "/docs/techniques/cookies",
    "section": "techniques",
    "headings": [],
    "content": "import { Controller, Get, Req } from '@nl-framework/http'; @Controller('/profile') export class ProfileController { @Get('/') me(@Req() req: Request) { const cookieHeader = req.headers.get('cookie') ?? ''; const cookies = Object.fromEntries( cookieHeader .split(';') .map((pair) => pair.trim()) .filter(Boolean) .map((pair) => pair.split('=').map(decodeURIComponent) as [string, string]), ); return { userId: cookies['session_id'] ?? null }; } } import { Controller, Post } from '@nl-framework/http'; @Controller('/auth') export class AuthController { @Post('/login') async login(): Promise<Response> { const body = JSON.stringify({ ok: true }); return new Response(body, { status: 200, headers: { 'content-type': 'application/json', // Secure, HttpOnly, SameSite for safety 'set-cookie': [ \\`session_id=\\${encodeURIComponent('abc123')}; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=86400\\`, ], }, }); } } // Overwrite with expired cookie const expireCookie = 'session_id=; Path=/; HttpOnly; Secure; SameSite=Lax; Max-Age=0'; return new Response(JSON.stringify({ ok: true }), { headers: { 'set-cookie': expireCookie }, }); // With Better Auth multi-tenant loader, set a per-tenant prefix (e.g., mt-acme.session_token) // in your tenant resolver so cookies stay isolated: return { betterAuth: { /* ... */ }, adapter, advanced: { cookiePrefix: \\`mt-\\${tenantId}\\` }, }; Techniques Use the native Request/Response APIs to manage cookies in Nael HTTP handlers. Parse inbound cookies, set secure flags on responses, and isolate tenant cookies when using Better Auth. Access cookies via req.headers.get('cookie'). Parse into a map for easy lookup: Write Set-Cookie headers directly. Always include HttpOnly, Secure, and an appropriate SameSite value (Lax for most API cookies; None when shared across origins with Secure). Better Auth supports per-tenant cookie prefixes. Set cookiePrefix in the tenant resolver to keep session cookies distinct across tenants. See Better Auth for full session guidance and multi-tenant examples."
  },
  {
    "title": "Validation · Techniques",
    "description": "Validate and transform incoming data with class-validator and class-transformer across HTTP and GraphQL in Nael applications.",
    "href": "/docs/techniques/validation",
    "section": "techniques",
    "headings": [],
    "content": "import { Type } from 'class-transformer'; import { IsEmail, IsInt, IsOptional, IsString, Min, MinLength } from 'class-validator'; export class CreateUserDto { @IsEmail() email!: string; @IsString() @MinLength(2) name!: string; @IsOptional() @IsInt() @Min(13) @Type(() => Number) age?: number; } import { Body, Controller, Post } from '@nl-framework/http'; @Controller('/users') export class UsersController { @Post('/') create(@Body() payload: CreateUserDto) { // Payload is already a CreateUserDto instance; unknown keys are stripped return this.service.register(payload); } constructor(private readonly service: UsersService) {} } import { Body, Controller, Put, UsePipes, ValidationPipe } from '@nl-framework/http'; import { ApplicationException } from '@nl-framework/core'; @Controller('/users') @UsePipes(new ValidationPipe({ transform: true, whitelist: true, skipMissingProperties: true, // friendly for PATCH-style updates groups: ['update'], exceptionFactory: (issues) => ApplicationException.validationError( 'User payload invalid', { issues }, ), })) export class UsersController { @Put('/:id') update(@Body() payload: UpdateUserDto) { return this.service.update(payload); } } import { Resolver, Mutation, Arg, InputType, Field, Int } from '@nl-framework/graphql'; import { IsEmail, IsOptional, IsString, Min } from 'class-validator'; import { Type } from 'class-transformer'; @InputType() class UpdateProfileInput { @Field() @IsString() id!: string; @Field({ nullable: true }) @IsOptional() @IsEmail() email?: string; @Field(() => Int, { nullable: true }) @IsOptional() @Min(1) @Type(() => Number) visits?: number; } @Resolver() export class ProfileResolver { @Mutation(() => Boolean) updateProfile(@Arg('input', () => UpdateProfileInput) input: UpdateProfileInput) { // input arrives as a sanitized UpdateProfileInput instance return true; } } import { transformAndValidate } from '@nl-framework/core'; export async function normalizeRow(raw: unknown) { return transformAndValidate({ metatype: ImportRowDto, value: raw, sanitize: true, validatorOptions: { forbidUnknownValues: true, groups: ['import'], }, }); } export async function validateBatch(rows: unknown[]) { return Promise.all(rows.map((row) => normalizeRow(row))); } Techniques Nael leans on class-validator and class-transformer to keep payloads predictable. Define DTOs once and reuse them across HTTP controllers and GraphQL resolvers while the framework handles conversion, whitelisting, and user-friendly error responses. Decorate classes with validation rules and optional transformation hints. Nael calls class-transformer with enableImplicitConversion and exposeDefaultValues enabled, so strings like &quot;5&quot; can hydrate numeric fields and defaults populate when values are missing. Any @Body() parameter typed as a class triggers transformation + validation before your controller runs. Payloads are converted into class instances, unknown properties are stripped (whitelist on), and invalid data returns a 400 response shaped as '}. Heads up: Automatic validation only kicks in for class metatypes (not primitives or plain arrays). For array payloads or bespoke parsing, loop through items with transformAndValidate or a custom pipe before persisting them. Attach ValidationPipe when you need group-specific rules, to tolerate partial updates with skipMissingProperties, or to throw a custom ApplicationException. Pipes run after the framework&apos;s built-in body sanitization and are ideal for query params, headers, or custom decorators that also carry DTOs. Combine with parsing pipes (like ParseIntPipe or ParseBoolPipe) to coerce primitives before validation executes. Resolver params backed by @InputType() classes are transformed and validated automatically. Arrays of input types are supported when you describe the element type in the argument decorator. Failures surface as BADUSERINPUT errors with extensions.validation mirroring the HTTP issues format. Reach for transformAndValidate from @nl-framework/core in background jobs, CLI scripts, microservices, or array-processing endpoints. It returns typed instances or throws ValidationException with a concise issues list you can map to your own error model. See Pipes for more on composing transformations, or explore GraphQL exception handling to customize the error surface."
  }
]