---
title: "Providers · NL Framework"
description: "Learn about providers, dependency injection, and service management in NL Framework."
---

import Link from "next/link";
import { CodeBlock } from "@/components/shared/simple-code-block";

export const basicService = `import { Injectable } from '@nl-framework/core';

@Injectable()
export class UsersService {
  private readonly users: User[] = [];

  create(user: User) {
    this.users.push(user);
  }

  findAll(): User[] {
    return this.users;
  }

  findOne(id: number): User {
    return this.users.find(user => user.id === id);
  }
}`;

export const injectService = `import { Controller, Get, Post, Body, Param } from '@nl-framework/http';

@Controller('users')
export class UsersController {
  constructor(private usersService: UsersService) {}

  @Post()
  async create(@Body() createUserDto: CreateUserDto) {
    this.usersService.create(createUserDto);
  }

  @Get()
  async findAll() {
    return this.usersService.findAll();
  }

  @Get(':id')
  async findOne(@Param('id') id: string) {
    return this.usersService.findOne(+id);
  }
}`;

export const scopedProvider = `import { Injectable, Scope } from '@nl-framework/core';

@Injectable({ scope: Scope.REQUEST })
export class UsersService {}`;

export const optionalDeps = `import { Injectable, Optional, Inject } from '@nl-framework/core';

@Injectable()
export class HttpService {
  constructor(@Optional() @Inject('HTTP_OPTIONS') private httpOptions) {}
}`;

export const propertyInjection = `import { Injectable, Inject } from '@nl-framework/core';

@Injectable()
export class HttpService {
  @Inject('HTTP_OPTIONS')
  private readonly httpOptions;
}`;

export const providerRegistration = `import { Module } from '@nl-framework/core';

@Module({
  controllers: [UsersController],
  providers: [UsersService],
})
export class UsersModule {}`;

export const customProvider = `const connectionProvider = {
  provide: 'CONNECTION',
  useValue: connection,
};

@Module({
  providers: [connectionProvider],
})
export class AppModule {}`;

export const useClass = `const configServiceProvider = {
  provide: ConfigService,
  useClass: process.env.NODE_ENV === 'development'
    ? DevelopmentConfigService
    : ProductionConfigService,
};

@Module({
  providers: [configServiceProvider],
})
export class AppModule {}`;

export const useFactory = `const connectionFactory = {
  provide: 'CONNECTION',
  useFactory: (optionsProvider: OptionsProvider) => {
    const options = optionsProvider.get();
    return new DatabaseConnection(options);
  },
  inject: [OptionsProvider],
};

@Module({
  providers: [connectionFactory],
})
export class AppModule {}`;

export const asyncProvider = `{
  provide: 'ASYNC_CONNECTION',
  useFactory: async () => {
    const connection = await createConnection();
    return connection;
  },
}`;

export const exportProvider = `import { Module } from '@nl-framework/core';

@Module({
  providers: [UsersService],
  exports: [UsersService],
})
export class UsersModule {}`;

<div className="space-y-10">
      <div className="space-y-3">
        <div className="text-sm uppercase tracking-wide text-muted-foreground">Overview</div>
        <h1 className="text-4xl font-semibold">Providers</h1>
        <div className="max-w-2xl text-muted-foreground">
          Providers are a fundamental concept in NL Framework. Many of the basic classes may be treated as providers – services, repositories, factories, helpers, and so on.
          The main idea of a provider is that it can be injected as a dependency; this means objects can create various relationships with each other.
        </div>
      </div>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Services</h2>
        <div className="text-muted-foreground">
          Let&apos;s start by creating a simple `UsersService`. This service will be responsible for data storage and retrieval,
          and is designed to be used by the `UsersController`, so it&apos;s a good candidate to be defined as a provider.
        </div>
        <CodeBlock code={basicService} title="users.service.ts" />
        <div className="text-sm text-muted-foreground">
          The `@Injectable()` decorator attaches metadata, which declares that `UsersService` is a class that can be managed
          by the NL Framework IoC container. This example also uses a `User` interface, which probably looks something like this:
        </div>
        <CodeBlock code={`export interface User {\n  id: number;\n  name: string;\n  email: string;\n}`} title="interfaces/user.interface.ts" />
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Dependency injection</h2>
        <div className="text-muted-foreground">
          NL Framework is built around the strong design pattern commonly known as Dependency injection. We recommend reading a great article about this concept
          in the official <Link className="text-primary" href="https://angular.io/guide/dependency-injection" rel="noreferrer" target="_blank">Angular</Link> documentation.
        </div>
        <div className="text-muted-foreground">
          In NL Framework, thanks to TypeScript capabilities, it&apos;s extremely easy to manage dependencies because they are resolved just by type.
          In the example below, NL Framework will resolve the `usersService` by creating and returning an instance of `UsersService` (or,
          in the normal case of a singleton, returning the existing instance if it has already been requested elsewhere). This dependency is resolved and passed to your controller&apos;s constructor:
        </div>
        <CodeBlock code={injectService} title="users.controller.ts" />
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Scopes</h2>
        <div className="text-muted-foreground">
          Providers normally have a lifetime (&quot;scope&quot;) synchronized with the application lifecycle. When the application is bootstrapped,
          every dependency must be resolved, and therefore every provider has to be instantiated. Similarly, when the application shuts down,
          each provider will be destroyed. However, there are ways to make your provider lifetime request-scoped as well.
        </div>
        <CodeBlock code={scopedProvider} title="Request-scoped provider" />
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Optional providers</h2>
        <div className="text-muted-foreground">
          Occasionally, you might have dependencies which do not necessarily have to be resolved. For instance, your class may depend on a configuration object,
          but if none is passed, the default values should be used. In such a case, the dependency becomes optional.
        </div>
        <CodeBlock code={optionalDeps} title="Optional dependency" />
        <div className="text-sm text-muted-foreground">
          In the example above, we are using the `@Optional()` decorator, which marks a dependency as optional.
        </div>
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Property-based injection</h2>
        <div className="text-muted-foreground">
          The technique we&apos;ve used so far is called constructor-based injection, as providers are injected via the constructor method.
          In some very specific cases, property-based injection might be useful. For instance, if your top-level class depends on either
          one or multiple providers, passing them all the way up by calling `super()` in sub-classes from the constructor can be very tedious.
        </div>
        <CodeBlock code={propertyInjection} title="Property injection" />
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Provider registration</h2>
        <div className="text-muted-foreground">
          Now that we have defined a provider (`UsersService`), and we have a consumer of that service (`UsersController`),
          we need to register the service with NL Framework so that it can perform the injection. We do this by editing our module file and adding
          the service to the `providers` array of the `@Module()` decorator.
        </div>
        <CodeBlock code={providerRegistration} title="users.module.ts" />
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Custom providers</h2>
        <div className="text-muted-foreground">
          NL Framework has a built-in inversion of control (&quot;IoC&quot;) container that resolves relationships between providers.
          This feature underlies the dependency injection feature described above, but is in fact far more powerful than what we&apos;ve described so far.
        </div>
        <h3 className="text-xl font-semibold">Value providers: useValue</h3>
        <div className="text-muted-foreground">
          The `useValue` syntax is useful for injecting a constant value, putting an external library into the NL Framework container,
          or replacing a real implementation with a mock object.
        </div>
        <CodeBlock code={customProvider} title="Custom value provider" />

        <h3 className="text-xl font-semibold">Class providers: useClass</h3>
        <div className="text-muted-foreground">
          The `useClass` syntax allows you to dynamically determine a class that a token should resolve to.
        </div>
        <CodeBlock code={useClass} title="Dynamic class provider" />

        <h3 className="text-xl font-semibold">Factory providers: useFactory</h3>
        <div className="text-muted-foreground">
          The `useFactory` syntax allows for creating providers dynamically. The actual provider will be supplied by the value
          returned from a factory function.
        </div>
        <CodeBlock code={useFactory} title="Factory provider" />
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Asynchronous providers</h2>
        <div className="text-muted-foreground">
          At times, the application start should be delayed until one or more asynchronous tasks are completed. For example,
          you may not want to start accepting requests until the connection with the database has been established. You can achieve this using asynchronous providers.
        </div>
        <CodeBlock code={asyncProvider} title="Async provider" />
        <div className="text-sm text-muted-foreground">
          The application will wait for the async provider to resolve before bootstrapping. This pattern works with `useFactory` syntax.
        </div>
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Export providers</h2>
        <div className="text-muted-foreground">
          Any provider that is part of a module can be exported. They can be exported either by their token or by their full provider object.
        </div>
        <CodeBlock code={exportProvider} title="Exporting providers" />
      </section>

      <section className="space-y-3">
        <h2 className="text-2xl font-semibold">What&apos;s next?</h2>
        <div className="text-muted-foreground">
          Continue to <Link className="text-primary" href="/docs/modules">Modules</Link> to learn how to organize your application structure,
          or explore <Link className="text-primary" href="/docs/middleware">Middleware</Link> for request processing.
        </div>
      </section>
    </div>
