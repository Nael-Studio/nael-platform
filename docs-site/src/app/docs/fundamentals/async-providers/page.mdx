---
title: 'Async providers · NL Framework'
description: 'Configure modules and tokens that depend on asynchronous work using useFactory, useClass, and useExisting patterns.'
---

import { Badge } from '@/components/ui/badge';
import { CodeBlock } from '@/components/shared/simple-code-block';

export const factoryRegistration = `import { Module } from '@nl-framework/core';
import { ConfigModule, ConfigService } from '@nl-framework/config';
import { DatabaseModule } from '@acme/database'; // imagine a feature module that exposes forRootAsync

@Module({
  imports: [
    ConfigModule.forRoot({ isGlobal: true }),
    DatabaseModule.forRootAsync({
      inject: [ConfigService],
      useFactory: async (config: ConfigService) => ({
        url: config.get('database.url'),
        ssl: config.get('database.sslEnabled'),
        maxConnections: 10,
      }),
    }),
  ],
})
export class AppModule {}`;

export const optionsFactorySnippet = `import { Injectable } from '@nl-framework/core';
import type { BetterAuthModuleOptions, BetterAuthOptionsFactory } from '@nl-framework/auth';
import { BetterAuthModule } from '@nl-framework/auth';
import { ConfigService } from '@nl-framework/config';

@Injectable()
class AuthEnvService implements BetterAuthOptionsFactory {
  constructor(private readonly config: ConfigService) {}

  async createBetterAuthOptions(): Promise<BetterAuthModuleOptions> {
    return {
      projectId: this.config.get('auth.projectId'),
      secret: await this.config.getSecret('auth.secret'),
    };
  }
}

@Module({
  imports: [
    BetterAuthModule.registerAsync({
      useClass: AuthEnvService,
      imports: [ConfigModule],
    }),
  ],
})
export class AuthModule {}`;

export const useExistingSnippet = `@Module({
  providers: [AuthEnvService],
  exports: [AuthEnvService],
})
export class SharedConfigModule {}

@Module({
  imports: [
    SharedConfigModule,
    BetterAuthModule.registerAsync({
      useExisting: AuthEnvService,
    }),
  ],
})
export class AuthModule {}`;

export const lifecycleSnippet = `@Module({
  imports: [CacheModule.forRootAsync({ useFactory: async () => ({ url: process.env.REDIS_URL! }) })],
})
export class AppModule implements OnModuleInit {
  constructor(private readonly cache: CacheService) {}

  async onModuleInit() {
    await this.cache.ping();
  }
}`;

<article className="space-y-8">
      <div className="space-y-3">
        <Badge className="bg-amber-100 text-amber-900 dark:bg-amber-900/30 dark:text-amber-50">Fundamentals</Badge>
        <h1 className="text-4xl font-semibold tracking-tight">Async providers</h1>
        <div className="text-lg text-muted-foreground">
          Not every dependency is ready the moment your module file executes. Async providers let NL Framework wait for Promises, wire dependencies first,
          and share the resolved value after bootstrapping—perfect for database pools, SDK clients, or secrets loaded from external services.
        </div>
      </div>

      <section className="space-y-4" id="use-factory">
        <h2 className="text-2xl font-semibold">useFactory with injected deps</h2>
        <div className="text-muted-foreground">
          The most flexible form is `useFactory`. List whatever providers you need inside `inject`, perform async work, and return
          either the provider value or the options object a module needs. NL Framework will await the Promise before exposing the dependency downstream.
        </div>
        <CodeBlock code={factoryRegistration} title="DatabaseModule.forRootAsync" />
        <div className="text-sm text-muted-foreground">
          Keep factory functions side-effect free—no global state—and push configuration concerns into dedicated services to simplify testing.
        </div>
      </section>

      <section className="space-y-4" id="use-class">
        <h2 className="text-2xl font-semibold">useClass & factory interfaces</h2>
        <div className="text-muted-foreground">
          Many built-in modules (Config, BetterAuth, ORM, Scheduler) expose an `OptionsFactory` interface. Implement it when you prefer
          an injectable class over an inline function. NL Framework instantiates the class once (respecting scope) and calls the factory method.
        </div>
        <CodeBlock code={optionsFactorySnippet} title="BetterAuthModule.registerAsync(useClass)" />
        <div className="text-sm text-muted-foreground">
          Classes can leverage constructor injection, caching, or memoization. They also compose nicely with testing modules that override the provider.
        </div>
      </section>

      <section className="space-y-4" id="use-existing">
        <h2 className="text-2xl font-semibold">useExisting for re-use</h2>
        <div className="text-muted-foreground">
          If a module already provides the correct factory class, `useExisting` prevents duplicate instances. NL Framework will reference the
          pre-registered token instead of creating a new class.
        </div>
        <CodeBlock code={useExistingSnippet} title="Sharing an options factory" />
        <div className="text-sm text-muted-foreground">
          This pattern excels in monorepos where multiple features need the same config loader. Export the factory class once, then point to it via
          `useExisting` everywhere else.
        </div>
      </section>

      <section className="space-y-4" id="lifecycle">
        <h2 className="text-2xl font-semibold">Bootstrapping order & lifecycle hooks</h2>
        <div className="text-muted-foreground">
          Async providers delay application bootstrap until they resolve. You can safely run sanity checks in `onModuleInit` or
          `onApplicationBootstrap` knowing the dependencies are ready.
        </div>
        <CodeBlock code={lifecycleSnippet} title="Validating an async provider" />
        <div className="text-sm text-muted-foreground">
          When a provider must refresh periodically (e.g., rotating secrets), create a scoped factory or schedule refresh logic after the app starts.
        </div>
      </section>
    </article>
