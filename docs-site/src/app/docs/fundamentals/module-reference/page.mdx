---
title: 'Module reference Â· Nael Platform'
description: 'Use ModuleRef to resolve providers dynamically, create scoped instances, and interact with module-scoped injectors.'
---

import { Badge } from '@/components/ui/badge';
import { CodeBlock } from '@/components/shared/simple-code-block';

export const injectModuleRef = `import { Injectable } from '@nl-framework/core';
import { ModuleRef } from '@nl-framework/core';

@Injectable()
export class ReportsService {
  constructor(private readonly moduleRef: ModuleRef) {}

  async sendWeeklyReport() {
    const email = await this.moduleRef.resolve(EmailService);
    await email.send('ops@example.com', 'Weekly status', '...');
  }
}`;

export const strictResolution = `const cache = await this.moduleRef.resolve(CacheService, {
  strict: true,
});
// Throws if CacheService is not part of the current module tree.`;

export const transientLookup = `const exporter = await this.moduleRef.create(ExporterService);
await exporter.export();
// create() bypasses the shared singleton and gives you a fresh instance.`;

export const moduleTokenLookup = `const billingModule = this.moduleRef.get('BillingModule', { strict: false });
const billingService = billingModule.get(BillingService);`;

<article className="space-y-8">
      <div className="space-y-3">
        <Badge className="bg-amber-100 text-amber-900 dark:bg-amber-900/30 dark:text-amber-50">Fundamentals</Badge>
        <h1 className="text-4xl font-semibold tracking-tight">Module reference</h1>
        <div className="text-lg text-muted-foreground">
          `ModuleRef` exposes the underlying injector so you can look up providers outside of constructor injection. Use it sparingly for
          dynamic workflows, plug-in systems, or bridging circular dependencies.
        </div>
      </div>

      <section className="space-y-4" id="resolve">
        <h2 className="text-2xl font-semibold">Resolving providers at runtime</h2>
        <div className="text-muted-foreground">
          Call `moduleRef.resolve(Token)` to retrieve a provider using the same injection graph Nael builds at bootstrap. The promise resolves
          once the provider is ready; if it was request-scoped, it will honor the current context.
        </div>
        <CodeBlock code={injectModuleRef} title="Inject ModuleRef" />
      </section>

      <section className="space-y-4" id="strict">
        <h2 className="text-2xl font-semibold">Controlling lookup boundaries</h2>
        <div className="text-muted-foreground">
          By default, `resolve()` searches the entire module graph. Pass `strict: true` to restrict the lookup to the current module
          (and its providers). This is useful for enforcing encapsulation.
        </div>
        <CodeBlock code={strictResolution} title="Strict resolution" />
      </section>

      <section className="space-y-4" id="transient">
        <h2 className="text-2xl font-semibold">Creating new instances</h2>
        <div className="text-muted-foreground">
          Use `moduleRef.create()` when you need a throwaway instance that should not be cached by the container. Nael will construct the
          provider and resolve its dependencies, but ownership stays with the caller.
        </div>
        <CodeBlock code={transientLookup} title="Per-call instances" />
      </section>

      <section className="space-y-4" id="modules">
        <h2 className="text-2xl font-semibold">Accessing module-scoped providers</h2>
        <div className="text-muted-foreground">
          When you need to traverse module boundaries manually, `moduleRef.get()` accepts strings, class tokens, or symbols. Combine it with
          `strict: false` to reach exported providers from imported modules.
        </div>
        <CodeBlock code={moduleTokenLookup} title="Look up by module token" />
        <div className="text-sm text-muted-foreground">
          Prefer constructor injection or explicit exports whenever possible; ModuleRef is a powerful escape hatch but can reduce clarity if overused.
        </div>
      </section>
    </article>
