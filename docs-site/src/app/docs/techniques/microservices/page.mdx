---
title: 'Microservices & Scheduler Â· Techniques'
description: 'Wire Dapr pub/sub, background jobs, and queue consumers inside Nael services.'
---

import { CodeBlock } from '@/components/shared/simple-code-block';
import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';

export const installMicro = `bun add @nl-framework/microservices @nl-framework/scheduler dapr-client`;

export const daprConsumer = `@Subscriber({
  pubsubName: "fleet-events",
  topic: "vehicle.assigned",
})
export class VehicleAssignedConsumer {
  constructor(private readonly logger: LoggerService) {}

  async handle(data: VehicleAssignedPayload) {
    this.logger.log("vehicle.assigned", data)
  }
}`;

export const schedulerExample = `@Cron("0 */5 * * * *", { name: "warm-cache" })
handleCacheWarmup() {
  return this.cache.prime()
}

@Interval(60_000)
handleMetricsPush() {
  return this.metrics.flush()
}`;

export const sidecar = `dapr run \
  --app-id fleet-service \
  --app-port 3001 \
  --dapr-http-port 3500 \
  --components-path ./examples/microservices/dapr \
  -- bun run --cwd examples/microservices dev`;

<div className="space-y-10">
      <div className="space-y-3">
        <div className="text-sm uppercase tracking-wide text-muted-foreground">Techniques</div>
        <h1 className="text-4xl font-semibold">Microservices & Scheduler</h1>
        <div className="max-w-2xl text-muted-foreground">
          Scale beyond HTTP by leaning on the Dapr-friendly microservices module and the Bun Worker-based scheduler.
          Both ship decorators that feel like NestJS while embracing streaming-friendly transports.
        </div>
      </div>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Install modules</h2>
        <div className="text-muted-foreground">
          Add the microservices and scheduler packages to any service that needs async work. Dapr components are
          optional but recommended for durable pub/sub.
        </div>
        <CodeBlock code={installMicro} title="Install async packages" />
      </section>

      <section className="space-y-6">
        <Card className="border-border/70">
          <CardHeader>
            <CardTitle>Dapr subscribers</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            <div className="text-sm text-muted-foreground">
              Decorate a class with `@Subscriber()` to automatically register handlers with the Dapr sidecar.
              The framework handles signature validation, tracing, and poison queue retries.
            </div>
            <CodeBlock code={daprConsumer} title="vehicle.assigned" />
          </CardContent>
        </Card>
        <Card className="border-border/70">
          <CardHeader>
            <CardTitle>Scheduler decorators</CardTitle>
          </CardHeader>
          <CardContent className="space-y-3">
            <div className="text-sm text-muted-foreground">
              Cron, interval, and timeout decorators all run on Bun Workers so they don&apos;t block the main event loop.
              Each job automatically receives the DI container so you can inject repositories and services.
            </div>
            <CodeBlock code={schedulerExample} title="Cache warmers" />
          </CardContent>
        </Card>
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Local sidecars</h2>
        <div className="text-muted-foreground">
          Use the Dapr CLI to bootstrap pub/sub and state components locally. The microservices example already
          ships opinionated component YAMLs; copy them into your own repo or customize the topics.
        </div>
        <CodeBlock code={sidecar} title="Run sidecar" />
      </section>

      <section className="space-y-4">
        <h2 className="text-2xl font-semibold">Operational guidance</h2>
        <ul className="list-disc space-y-2 pl-5 text-sm text-muted-foreground">
          <li>Set <code>DAPR_TRACING_ENABLED=true</code> to feed traces into OpenTelemetry collectors.</li>
          <li>Use <code>nl doctor --checks microservices</code> to validate ports and component files.</li>
          <li>Register schedulers inside dedicated modules to simplify feature toggling.</li>
          <li>When deploying to Kubernetes, use the same <code>components/</code> folder referenced in the example repo.</li>
        </ul>
      </section>
    </div>
