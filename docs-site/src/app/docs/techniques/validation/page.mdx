---
title: 'Validation · Techniques'
description: 'Validate and transform incoming data with class-validator and class-transformer across HTTP and GraphQL in NL Framework applications.'
---

import Link from 'next/link';
import { Badge } from '@/components/ui/badge';
import { CodeBlock } from '@/components/shared/simple-code-block';

export const dtoExample = `import { Type } from 'class-transformer';
import { IsEmail, IsInt, IsOptional, IsString, Min, MinLength } from 'class-validator';

export class CreateUserDto {
  @IsEmail()
  email!: string;

  @IsString()
  @MinLength(2)
  name!: string;

  @IsOptional()
  @IsInt()
  @Min(13)
  @Type(() => Number)
  age?: number;
}`;

export const httpBodyValidation = `import { Body, Controller, Post } from '@nl-framework/http';

@Controller('/users')
export class UsersController {
  @Post('/')
  create(@Body() payload: CreateUserDto) {
    // Payload is already a CreateUserDto instance; unknown keys are stripped
    return this.service.register(payload);
  }

  constructor(private readonly service: UsersService) {}
}`;

export const validationPipeUsage = `import { Body, Controller, Put, UsePipes, ValidationPipe } from '@nl-framework/http';
import { ApplicationException } from '@nl-framework/core';

@Controller('/users')
@UsePipes(new ValidationPipe({
  transform: true,
  whitelist: true,
  skipMissingProperties: true, // friendly for PATCH-style updates
  groups: ['update'],
  exceptionFactory: (issues) => ApplicationException.validationError(
    'User payload invalid',
    { issues },
  ),
}))
export class UsersController {
  @Put('/:id')
  update(@Body() payload: UpdateUserDto) {
    return this.service.update(payload);
  }
}`;

export const graphqlValidation = `import { Resolver, Mutation, Arg, InputType, Field, Int } from '@nl-framework/graphql';
import { IsEmail, IsOptional, IsString, Min } from 'class-validator';
import { Type } from 'class-transformer';

@InputType()
class UpdateProfileInput {
  @Field()
  @IsString()
  id!: string;

  @Field({ nullable: true })
  @IsOptional()
  @IsEmail()
  email?: string;

  @Field(() => Int, { nullable: true })
  @IsOptional()
  @Min(1)
  @Type(() => Number)
  visits?: number;
}

@Resolver()
export class ProfileResolver {
  @Mutation(() => Boolean)
  updateProfile(@Arg('input', () => UpdateProfileInput) input: UpdateProfileInput) {
    // input arrives as a sanitized UpdateProfileInput instance
    return true;
  }
}`;

export const manualValidation = `import { transformAndValidate } from '@nl-framework/core';

export async function normalizeRow(raw: unknown) {
  return transformAndValidate({
    metatype: ImportRowDto,
    value: raw,
    sanitize: true,
    validatorOptions: {
      forbidUnknownValues: true,
      groups: ['import'],
    },
  });
}

export async function validateBatch(rows: unknown[]) {
  return Promise.all(rows.map((row) => normalizeRow(row)));
}`;

<article className="space-y-8">
      <div className="space-y-3">
        <Badge className="bg-emerald-100 text-emerald-900 dark:bg-emerald-900/30 dark:text-emerald-50">
          Techniques
        </Badge>
        <h1 className="text-4xl font-semibold tracking-tight">Validation</h1>
        <div className="text-lg text-muted-foreground">
          NL Framework leans on `class-validator` and `class-transformer` to keep payloads predictable.
          Define DTOs once and reuse them across HTTP controllers and GraphQL resolvers while the framework handles
          conversion, whitelisting, and user-friendly error responses.
        </div>
      </div>

      <section className="space-y-4" id="dtos">
        <h2 className="text-2xl font-semibold">Annotate DTOs</h2>
        <div className="text-muted-foreground">
          Decorate classes with validation rules and optional transformation hints. NL Framework calls `class-transformer`{' '}
          with `enableImplicitConversion` and `exposeDefaultValues` enabled, so strings like
          `&quot;5&quot;` can hydrate numeric fields and defaults populate when values are missing.
        </div>
        <CodeBlock code={dtoExample} title="create-user.dto.ts" />
      </section>

      <section className="space-y-4" id="http">
        <h2 className="text-2xl font-semibold">HTTP bodies validate automatically</h2>
        <div className="text-muted-foreground">
          Any `@Body()` parameter typed as a class triggers transformation + validation before your controller
          runs. Payloads are converted into class instances, unknown properties are stripped (`whitelist` on),
          and invalid data returns a 400 response shaped as `{'{ message, issues }'}`.
        </div>
        <CodeBlock code={httpBodyValidation} title="users.controller.ts" />
        <div className="rounded-lg border border-amber-500/50 bg-amber-500/10 p-4">
          <div className="text-sm text-amber-700 dark:text-amber-400">
            <strong>Heads up:</strong> Automatic validation only kicks in for class metatypes (not primitives or plain arrays).
            For array payloads or bespoke parsing, loop through items with `transformAndValidate` or a custom pipe
            before persisting them.
          </div>
        </div>
      </section>

      <section className="space-y-4" id="pipes">
        <h2 className="text-2xl font-semibold">Fine-tune with pipes</h2>
        <div className="text-muted-foreground">
          Attach `ValidationPipe` when you need group-specific rules, to tolerate partial updates with{' '}
          `skipMissingProperties`, or to throw a custom `ApplicationException`. Pipes run after the
          framework&apos;s built-in body sanitization and are ideal for query params, headers, or custom decorators that also
          carry DTOs.
        </div>
        <CodeBlock code={validationPipeUsage} title="users.controller.ts" />
        <div className="text-sm text-muted-foreground">
          Combine with parsing pipes (like `ParseIntPipe` or `ParseBoolPipe`) to coerce primitives
          before validation executes.
        </div>
      </section>

      <section className="space-y-4" id="graphql">
        <h2 className="text-2xl font-semibold">GraphQL arguments are sanitized</h2>
        <div className="text-muted-foreground">
          Resolver params backed by `@InputType()` classes are transformed and validated automatically. Arrays
          of input types are supported when you describe the element type in the argument decorator. Failures surface as
          `BAD_USER_INPUT` errors with `extensions.validation` mirroring the HTTP `issues` format.
        </div>
        <CodeBlock code={graphqlValidation} title="profile.resolver.ts" />
      </section>

      <section className="space-y-4" id="utility">
        <h2 className="text-2xl font-semibold">Reuse the utility anywhere</h2>
        <div className="text-muted-foreground">
          Reach for `transformAndValidate` from `@nl-framework/core` in background jobs, CLI scripts,
          microservices, or array-processing endpoints. It returns typed instances or throws `ValidationException`{' '}
          with a concise `issues` list you can map to your own error model.
        </div>
        <CodeBlock code={manualValidation} title="transform-and-validate.ts" />
      </section>

      <section className="space-y-3" id="tips">
        <h2 className="text-2xl font-semibold">Best practices</h2>
        <ul className="list-disc pl-6 text-muted-foreground">
          <li>Share DTO classes between HTTP and GraphQL to keep validation rules consistent.</li>
          <li>Use <code>@Type()</code> from <code>class-transformer</code> for nested objects, dates, and arrays to avoid ambiguous conversions.</li>
          <li>Bubble <code>ValidationException</code> details into <code>ApplicationException.validationError</code> when you need transport-agnostic errors.</li>
          <li>Keep validators close to the domain; treat DTOs as the contract boundary rather than sprinkling checks inside controllers.</li>
          <li>Log invalid payloads carefully—strip secrets before logging since validation runs before guards or interceptors.</li>
        </ul>
        <div className="text-sm text-muted-foreground">
          See <Link className="text-primary underline" href="/docs/pipes">Pipes</Link> for more on composing transformations,
          or explore <Link className="text-primary underline" href="/docs/graphql/exception-handling">GraphQL exception handling</Link>{' '}
          to customize the error surface.
        </div>
      </section>
    </article>
