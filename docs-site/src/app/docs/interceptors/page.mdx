---
title: 'Interceptors - NL Framework'
description: 'Learn how to extend request/response behavior with interceptors in NL Framework.'
---

import { Badge } from '@/components/ui/badge';
import { Card, CardContent } from '@/components/ui/card';
import { CodeBlock } from '@/components/shared/simple-code-block';

export const interceptorInterface = `import { Injectable } from '@nl-framework/core';
import { CallHandler, HttpInterceptor, HttpExecutionContext } from '@nl-framework/http';

@Injectable()
export class LoggingInterceptor implements HttpInterceptor {
  async intercept(context: HttpExecutionContext, next: CallHandler) {
    const start = Date.now();
    console.log('Before handler', context.getRoute().handlerName);

    const result = await next.handle();

    console.log('After handler', Date.now() - start, 'ms');
    return result;
  }
}`;

export const controllerUsage = `import { Controller, Get } from '@nl-framework/http';
import { UseInterceptors } from '@nl-framework/core';

@Controller('/reports')
@UseInterceptors(LoggingInterceptor)
export class ReportsController {
  @Get()
  async list() {
    return { reports: [] };
  }

  @Get('/daily')
  @UseInterceptors(RequestTimingInterceptor)
  daily() {
    return { status: 'ok' };
  }
}`;

export const functionalInterceptor = `import { InterceptorFunction } from '@nl-framework/http';

export const CacheInterceptor: InterceptorFunction = async (context, next) => {
  const cacheKey = context.getRoute().controller?.name + ':' + context.getRequest().url;
  const cached = await context.getContainer().resolve(CacheStore).get(cacheKey);
  if (cached) {
    return new Response(JSON.stringify(cached), {
      headers: { 'content-type': 'application/json' },
    });
  }

  const result = await next.handle();
  await context.getContainer().resolve(CacheStore).set(cacheKey, result);
  return result;
};

@Controller('/inventory')
export class InventoryController {
  @Get()
  @UseInterceptors(CacheInterceptor)
  list() {
    return this.service.all();
  }
}`;

export const globalInterceptor = `import { registerHttpInterceptor } from '@nl-framework/http';

registerHttpInterceptor(LoggingInterceptor);

const app = await createHttpApplication(AppModule, { port: 3000 });
await app.listen();`;

export const graphqlResolverInterceptors = `import { ObjectType, Field } from '@nl-framework/graphql';
import { Resolver, Query } from '@nl-framework/graphql';
import { UseInterceptors } from '@nl-framework/core';
import {
  GraphqlCallHandler,
  GraphqlInterceptor,
  registerGraphqlInterceptor,
} from '@nl-framework/graphql';

class EnvelopeInterceptor implements GraphqlInterceptor {
  async intercept(_context: unknown, next: GraphqlCallHandler) {
    const result = await next.handle();
    return { data: result };
  }
}

registerGraphqlInterceptor(EnvelopeInterceptor);

@ObjectType()
class Report {
  @Field()
  message!: string;
}

@Resolver(() => Report)
@UseInterceptors(EnvelopeInterceptor)
export class ReportResolver {
  @Query(() => Report)
  stats() {
    return { message: 'report' };
  }
}`;

export const responseMapping = `import { CallHandler, HttpExecutionContext, HttpInterceptor } from '@nl-framework/http';

export class EnvelopeInterceptor implements HttpInterceptor {
  async intercept(_context: HttpExecutionContext, next: CallHandler) {
    const result = await next.handle();
    return { data: result, at: new Date().toISOString() };
  }
}

@Controller('/users')
@UseInterceptors(EnvelopeInterceptor)
export class UsersController {
  @Get()
  list() {
    return [{ id: 1, email: 'ada@example.com' }];
  }
}`;

export const exceptionMapping = `import { HttpInterceptor, CallHandler, HttpExecutionContext } from '@nl-framework/http';
import { ApplicationException } from '@nl-framework/core';

export class ErrorsInterceptor implements HttpInterceptor {
  async intercept(_context: HttpExecutionContext, next: CallHandler) {
    try {
      return await next.handle();
    } catch (error) {
      if (error instanceof ApplicationException) {
        return new Response(
          JSON.stringify({ code: error.code, message: error.message }),
          { status: 502, headers: { 'content-type': 'application/json' } },
        );
      }
      throw error;
    }
  }
}`;

export const timeoutInterceptor = `import { HttpInterceptor, HttpExecutionContext, CallHandler } from '@nl-framework/http';

export class TimeoutInterceptor implements HttpInterceptor {
  constructor(private readonly timeoutMs = 5000) {}

  async intercept(_context: HttpExecutionContext, next: CallHandler) {
    const controller = new AbortController();
    const timeout = setTimeout(() => controller.abort(), this.timeoutMs);

    try {
      return await Promise.race([
        next.handle(),
        new Promise((_, reject) => controller.signal.addEventListener('abort', () => reject(new Error('Request timeout')))),
      ]);
    } finally {
      clearTimeout(timeout);
    }
  }
}`;

<article className="space-y-8">
      <div className="space-y-3">
        <Badge className="bg-purple-100 text-purple-900 dark:bg-purple-900/30 dark:text-purple-50">Runtime</Badge>
        <h1 className="text-4xl font-semibold tracking-tight">Interceptors</h1>
        <div className="text-lg text-muted-foreground">
          Interceptors wrap the execution of your route handlers, giving you a single place to run code before and after
          controllers execute. Use them for logging, response mapping, caching, exception translation, or any
          cross-cutting behavior.
        </div>
      </div>

      <Card className="border-purple-200 bg-purple-50 dark:border-purple-900/50 dark:bg-purple-950">
        <CardContent className="pt-6 text-sm text-purple-900 dark:text-purple-50">
          <div>
            <strong>Key pipeline order:</strong> middleware ➜ guards ➜ <strong>interceptors</strong> ➜ pipes ➜ handler ➜ filters.
            Interceptors share the same `HttpExecutionContext` as guards and can short-circuit requests by returning
            their own `Response` objects.
          </div>
        </CardContent>
      </Card>

      <section className="space-y-4" id="basics">
        <h2 className="text-2xl font-semibold">Implementing an interceptor</h2>
        <div className="text-muted-foreground">
          Interceptors implement the `HttpInterceptor` interface. They receive the execution context and a
          `CallHandler` that invokes the next interceptor (or ultimately the route handler).
        </div>
        <CodeBlock code={interceptorInterface} title="Logging interceptor" />
      </section>

      <section className="space-y-4" id="binding">
        <h2 className="text-2xl font-semibold">Binding interceptors</h2>
        <div className="text-muted-foreground">
          Use the `@UseInterceptors()` decorator to attach interceptors to controllers or individual handlers.
          Order matters—the first decorator argument wraps everything that follows. Import the decorator from
          `@nl-framework/core` (each transport re-exports it for backwards compatibility) so HTTP, GraphQL, and
          microservice handlers share the exact same metadata.
        </div>
        <CodeBlock code={controllerUsage} title="Controller and method scopes" />
      </section>

      <section className="space-y-4" id="functional">
        <h2 className="text-2xl font-semibold">Functional interceptors</h2>
        <div className="text-muted-foreground">
          For lightweight cases you can pass an `InterceptorFunction`. Functional interceptors are great for caching
          or analytics because they require no class registration.
        </div>
        <CodeBlock code={functionalInterceptor} title="Cache interceptor" />
      </section>

      <section className="space-y-4" id="global">
        <h2 className="text-2xl font-semibold">Global interceptors</h2>
        <div className="text-muted-foreground">
          Call `registerHttpInterceptor()` during bootstrap to run an interceptor for every request. Global
          interceptors execute outside controller scopes, so prefer functional interceptors or stateless classes.
        </div>
        <CodeBlock code={globalInterceptor} title="Register a global interceptor" />
      </section>

      <section className="space-y-4" id="graphql">
        <h2 className="text-2xl font-semibold">GraphQL resolvers</h2>
        <div className="text-muted-foreground">
          The same `@UseInterceptors()` decorator now wraps GraphQL resolvers. Combine controller-scoped and global
          `registerGraphqlInterceptor()` hooks to envelope responses, cache resolver results, or run observability spans
          without duplicating logic in HTTP land.
        </div>
        <CodeBlock code={graphqlResolverInterceptors} title="Resolver interceptors" />
      </section>

      <section className="space-y-4" id="response-mapping">
        <h2 className="text-2xl font-semibold">Transforming responses</h2>
        <div className="text-muted-foreground">
          Wrap handler results before they leave the server. This is helpful for enforcing envelope shapes, stripping null
          values, or appending metadata.
        </div>
        <CodeBlock code={responseMapping} title="Response envelopes" />
      </section>

      <section className="space-y-4" id="errors">
        <h2 className="text-2xl font-semibold">Translating exceptions</h2>
        <div className="text-muted-foreground">
          Because interceptors surround the handler, they can catch exceptions and transform them into framework-friendly
          responses. This is a good place to unify error payloads across HTTP and GraphQL transports.
        </div>
        <CodeBlock code={exceptionMapping} title="Normalize framework errors" />
      </section>

      <section className="space-y-4" id="timeouts">
        <h2 className="text-2xl font-semibold">Short-circuiting or timing out</h2>
        <div className="text-muted-foreground">
          Interceptors can completely bypass the handler. Return a cached `Response`, or race the handler against a
          timeout promise and throw when it takes too long.
        </div>
        <CodeBlock code={timeoutInterceptor} title="Timeout interceptor" />
      </section>

      <section className="space-y-3" id="best-practices">
        <h2 className="text-2xl font-semibold">Best practices</h2>
        <Card className="border-border/70">
          <CardContent className="space-y-2 pt-6 text-sm text-muted-foreground">
            <div><strong>Be explicit about order.</strong> Declare interceptors from most global to most specific to avoid surprises.</div>
            <div><strong>Keep them stateless when global.</strong> If an interceptor needs dependencies, register it via DI so the container can manage scope.</div>
            <div><strong>Return consistent shapes.</strong> When transforming responses, wrap data predictably so clients know what to expect.</div>
            <div><strong>Short-circuit intentionally.</strong> Always document when an interceptor might skip the underlying handler (caching, feature flags, etc.).</div>
          </CardContent>
        </Card>
      </section>
    </article>
